{"version":3,"sources":["helperFunctions/customAttr.ts","helperFunctions/color.ts","helperFunctions/helperFunctions.ts","mazesAndPatterns/mazesAndPatternsHelper.ts","pathfindingAlgorihms/pathfindingAlgorithmsOptions.ts","mazesAndPatterns/mazesAndPatternsOptions.ts","helperFunctions/props.ts","components/Nav.tsx","App.Functions.ts","pathfindingAlgorihms/aStar.ts","pathfindingAlgorihms/bidirectionalSearch.ts","pathfindingAlgorihms/dijkstras.ts","pathfindingAlgorihms/breadthFirstSearch.ts","pathfindingAlgorihms/depthFirstSearch.ts","components/TopNav.tsx","components/BottomNav.tsx","components/SideNav.tsx","components/MazesPatternSwitchButton.tsx","components/PathFindingGrid.tsx","mazesAndPatterns/basicRandomMaze.ts","mazesAndPatterns/animateDrawSideWalls.ts","mazesAndPatterns/recursiveDivision.ts","mazesAndPatterns/simpleStairPattern.ts","mazesAndPatterns/recursiveDivisionHorizontalSkew.ts","mazesAndPatterns/recursiveDivisionVerticalSkew.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["dataIsStartNode","dataIsTargetNode","dataIsWallNode","dataIsBombNode","dataIdx","dataIsFirstCol","dataIsLastCol","dataIsFirstRow","dataIsLastRow","dataIsGapNode","transparent","shortestPathNodeColor","wallNodeColor","visitedNodeColor","visitedNodeColorToBomb","gsap","registerPlugin","Draggable","initialIndex","isDarkMode","prevIndex","nodeInfoStart","index","isWallNode","x","y","nodeInfoTarget","nodeInfoBomb","nodeInfo","getDarkMode","setDarkMode","darkMode","visitedNodesBomb","visitedNodesTarget","pathNodes","gapNodes","wallNodes","startNode","targetNode","bombNode","getNodeStartInfo","getNodeTargetInfo","getNodeBombInfo","getAttr","node","attr","getAttribute","setAttr","value","setAttribute","addVisitedNode","toTarget","idx","nodeH","push","style","backgroundColor","addPathNode","addGapNode","addRemoveWallNode","isStartNode","isTargetNode","isBombNode","nodeIndex","indexOf","splice","classList","add","remove","createDraggble","className","noOfNodes","nodes","create","type","bounds","inertia","liveSnap","snap","endValue","Math","round","onPress","JSON","parse","stringify","onDrag","params","initialRow","floor","row","column","calculateNodeNewIndex","this","onDragEnd","set","appendChild","target","randomIntFromInterval","min","max","random","randomNumber","horizontal","vertical","randomIndex","length","chooseOrientation","height","width","orientation","timeouts","pushTimer","timer","resetTimeouts","newTimeouts","divide","startPos","animations","offset","tempAnimations","isGapIndex","gapIndex","i","nodeIdx","animationsNodeIndex","randomIdx","getStartXY","startXOptions","startYOptions","algorithms","setTimer","time","size","map","c","forEach","isNodeInFirstCol","isNodeInLastCol","isNodeInFirstRow","isNodeInLastRow","conditionUp","conditionDown","conditionLeft","conditionRight","findOptimalPath","auxPath","path","start","closedNodes","reverseNodes","get","unshift","nodeIdxParent","animateTargetNode","pathAniamtions","hideCover","showError","isPathFound","timerH","window","setTimeout","animatePath","animateBombNode","bombAnimations","targetAnimations","pathAnimations","isBombPathFound","pathfindingAlgorithmsOptions","key","text","mazesKeys","mazesAndPatternsOptions","mazesAndPatterns","name","arrowDown","direction","arrowUp","topNav","bottomNav","Nav","props","navType","arrowDirection","animateMazesAndPatterns","mazesPatternButtonsRef","currentActiveMazeAndPattern","mazesAndPatternsOptionsV","Menu","Item","href","header","DropdownButton","drop","id","title","maze","Dropdown","ref","elem","current","as","onClick","bombIndex","typeOfSearchAlgorithm","getBombIndex","getNewPfGridWithWallToggled","contains","clearPathNodes","clearVisitedNodes","clearWalls","resetMazesAndPatterns","clearGapNodes","addBomb","sideNav","addBombElem","children","j","document","createElement","addDarkMode","textContent","newNode","openNodes","Map","stopLoop","nodesH","noOfNodesH","getNeighbour","condition","parentCol","parentRow","targetCol","targetRow","minFCostNode","nodeNeighbours","col","gCost","abs","hCost","fCost","findNode","nodeTarget","targetType","minFCostArr","minFCost","minHCost","delete","isNeighbourInClosed","has","isNeighbourInOpen","aStar","noOfRows","clear","bombRow","bombCol","optimalPath","openNodesStart","openNodesTarget","closedNodesStart","closedNodesTarget","targetRowOfStartNode","targetColOfStartNode","targetRowOfTargetNode","targetColOfTargetNode","meetingPoint","getMinimumHCostArr","minHCostArr","getMinimumHCost","minHCostNode","getNodeNeighbour","bidirectionalSearchHelper","minHCostStartArr","minHCostTargetArr","minHCostNodeStart","minHCostNodeTarget","isInStartClosed","isInTargetClosed","bidirectionalSearch","minGCostNode","dijkstrasHelper","minGCostArr","minGCost","dijkstras","nodeStart","breadthFirstSearchHelper","queue","shift","breadthFirstSearch","queueT","DOWN","LEFT","RIGHT","directionToVisit","directionVisited","depthFirstSearchHelper","stack","indexOfDirection","pop","depthFirstSearch","stackT","TopNav","React","forwardRef","useState","showAlert","setShowAlert","showNoPath","setShowNoPath","options","pathFindingAlgorithmsOptions","pathFindingOptionVal","noPathTimer","showNoPathF","clearTimeout","padding","defaultValue","onChange","childNodes","sideNavAddBomb","disabled","e","preventDefault","showCover","visualize","Alert","position","right","left","margin","zIndex","variant","show","dismissible","onClose","transition","BottomNav","FAST","AVERAGE","SLOW","speedOnClick","setActive","sideNavRef","setDisplay","speedMenu","speedText","SideNav","setLeft","display","active","setLeftHelper","leftHelper","top","openSideNavRef","sideNavRefH","animateSideNavRefWidth","Icon","speedSideNavRef","fontWeight","resetBoard","infoOnClick","marginTop","marginLeft","MazesPatternSwitchButton","isSliderChecked","darkModeToggle","lightMode","marginRight","checked","onlabel","onstyle","offlabel","offstyle","Label","color","PathFindingGrid","pfGridHeight","pfGridRows","nodesRef","onMouseDown","onMouseEnter","iNode","createStartTargetNode","border","idxC","idxR","firstColNode","lastRowNode","wallNode","element","data-is-start-node","data-is-target-node","data-is-wall-node","data-is-bomb-node","data-idx","data-is-first-col","data-is-last-col","data-is-first-row","data-is-last-row","data-is-gap-node","basicRandomMaze","totalNodes","aniamtions","wallSideUp","wallSideDown","wallSideRightLeft","drawSideWalls","wallSide","init","final","animateDrawWalls","recursiveDivisionAnimations","animateRecursiveDivision","leftIdx","rightIdx","recursiveDivisionHelper","startX","startY","heightUp","heightDown","widthLeft","widthRight","recursiveDivision","simpleStairPattern","startRow","startCol","stairLength","endColRIght","startNodeA","targetNodeA","stairLengthH","status","upNodeLeftIdx","downNodeLeftIdx","downNodeLeftIdxRow","upNodeRightIdx","downNodeRightIdx","downNodeRightIdxRow","recursiveDivisionHorizontalSkewHelper","animateRecursiveDivisionHS","recursiveDivisionHorizontalSkew","recursiveDivisionVerticalSkewHelper","animateRecursiveDivisionVS","recursiveDivisionVerticalSkew","debounceTimer","pfGridWidth","pfGridTopMargin","isMousePressed","debounce","callBack","App","setPfGridHeight","setPfgridRows","topNavRef","useRef","bottomNavRef","pfGridRef","animateCoverRef","mazesPatternDetailRef","mazesPatternButtonsRefTop","mazesPatternButtonsRefBottom","calculateAndSetDimension","semanticUIDarkMode","elementH","borderBottom","borderTop","borderRight","semanticUILightMode","handleMouseUp","timeout","innerHeight","offsetTop","clientHeight","clientWidth","rows","startNodeH","currentRow","currentNode","generatePfGrid","useEffect","addEventListener","removeEventListener","startIdx","targetIdx","startIcon","targetIcon","isChecked","body","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.aa2a6775.chunk.js","sourcesContent":["/**\r\n * node custom attributes\r\n */\r\nexport const dataIsStartNode = 'data-is-start-node';\r\nexport const dataIsTargetNode = 'data-is-target-node';\r\nexport const dataIsWallNode = 'data-is-wall-node';\r\nexport const dataIsBombNode = 'data-is-bomb-node';\r\nexport const dataIdx = 'data-idx';\r\nexport const dataIsFirstCol = 'data-is-first-col';\r\nexport const dataIsLastCol = 'data-is-last-col';\r\nexport const dataIsFirstRow = 'data-is-first-row';\r\nexport const dataIsLastRow = 'data-is-last-row';\r\nexport const dataIsGapNode = 'data-is-gap-node';\r\n","export const transparent = 'transparent';\r\nexport const shortestPathNodeColor = '#ffff00';\r\nexport const wallNodeColor = '#016936';\r\nexport const visitedNodeColor = '#ff1493';\r\nexport const visitedNodeColorToBomb = '#a52a2a';\r\n","import { gsap } from 'gsap';\r\nimport { Draggable } from 'gsap/Draggable';\r\n// import { TweenLite } from 'gsap/all';\r\nimport { NodeInfoType } from './types';\r\nimport {\r\n  dataIsStartNode, dataIsTargetNode, dataIsWallNode, dataIsBombNode, dataIdx,\r\n  dataIsFirstCol, dataIsLastCol, dataIsFirstRow, dataIsLastRow, dataIsGapNode,\r\n} from './customAttr';\r\nimport {\r\n  shortestPathNodeColor, transparent, visitedNodeColor, visitedNodeColorToBomb, wallNodeColor,\r\n} from './color';\r\n\r\ngsap.registerPlugin(Draggable);\r\n\r\nlet initialIndex = 0;\r\nlet isDarkMode = false;\r\nlet prevIndex = 0;\r\n\r\nlet nodeInfoStart: NodeInfoType = {\r\n  index: -1,\r\n  isWallNode: 'false',\r\n  x: 0,\r\n  y: 0,\r\n};\r\n\r\nlet nodeInfoTarget: NodeInfoType = {\r\n  index: -1,\r\n  isWallNode: 'false',\r\n  x: 0,\r\n  y: 0,\r\n};\r\n\r\nlet nodeInfoBomb: NodeInfoType = {\r\n  index: -1,\r\n  isWallNode: 'false',\r\n  x: 0,\r\n  y: 0,\r\n};\r\n\r\nlet nodeInfo: NodeInfoType = {\r\n  index: -1,\r\n  isWallNode: 'false',\r\n  x: 0,\r\n  y: 0,\r\n};\r\n\r\n/**\r\n * Calculate node new index.\r\n * Array to be passed [nodeIndex, noOfNodes, x, y]\r\n * initial row: where the node is located according\r\n * to the number of nodes in a row and the row it is at\r\n * eg number of nodes = 9\r\n * row is 0 so initial row is 9 * 0;\r\n * row is 4 so inital row is 9 * 4;\r\n */\r\nconst calculateNodeNewIndex = (params: number[], type: string = '') => {\r\n  const initialRow = Math.floor(params[0] / params[1]) * params[1];\r\n  const row = ((params[3] / 25) * params[1]) + initialRow;\r\n  const column = (params[2] / 25) + (params[0] % params[1]);\r\n  if (type === 'prevIndex') return row + column;\r\n  nodeInfo.index = row + column;\r\n  return 0;\r\n};\r\n\r\n// get is dark mode\r\nexport const getDarkMode = () => isDarkMode;\r\n\r\n// set is dark mode\r\nexport const setDarkMode = (darkMode: boolean) => {\r\n  isDarkMode = darkMode;\r\n};\r\n\r\n// visited nodes array\r\nexport const visitedNodesBomb: number[] = [];\r\nexport const visitedNodesTarget: number[] = [];\r\n\r\n// path nodes array\r\nexport const pathNodes: number[] = [];\r\n\r\n// gap nodes array\r\nexport const gapNodes: number[] = [];\r\n\r\n// wall nodes array\r\nexport const wallNodes: number[] = [];\r\n\r\n// type of classes for draggable start, target and bomb node\r\nexport const startNode = 'start-node';\r\nexport const targetNode = 'target-node';\r\nexport const bombNode = 'bomb-node';\r\n\r\n// get nodeStartInfo\r\nexport const getNodeStartInfo = () => nodeInfoStart;\r\n\r\n// get nodeTargetInfo\r\nexport const getNodeTargetInfo = () => nodeInfoTarget;\r\n\r\n// get nodeBombInfo\r\nexport const getNodeBombInfo = () => nodeInfoBomb;\r\n\r\n// getAttr\r\nexport const getAttr = (node: HTMLDivElement, attr: string) => {\r\n  // start target wall bomb\r\n  switch (attr) {\r\n    case dataIsStartNode:\r\n      return node.getAttribute(attr);\r\n    case dataIsTargetNode:\r\n      return node.getAttribute(attr);\r\n    case dataIsWallNode:\r\n      return node.getAttribute(attr);\r\n    case dataIsBombNode:\r\n      return node.getAttribute(attr);\r\n    case dataIdx:\r\n      return node.getAttribute(attr);\r\n    case dataIsFirstCol:\r\n      return node.getAttribute(attr);\r\n    case dataIsLastCol:\r\n      return node.getAttribute(attr);\r\n    case dataIsFirstRow:\r\n      return node.getAttribute(attr);\r\n    case dataIsLastRow:\r\n      return node.getAttribute(attr);\r\n    case dataIsGapNode:\r\n      return node.getAttribute(attr);\r\n    default:\r\n      return node.getAttribute('');\r\n  }\r\n};\r\n\r\n// setAttr\r\nexport const setAttr = (node: HTMLDivElement, attr: string, value: any) => {\r\n  switch (attr) {\r\n    case dataIsStartNode:\r\n      node.setAttribute(attr, value);\r\n      break;\r\n    case dataIsTargetNode:\r\n      node.setAttribute(attr, value);\r\n      break;\r\n    case dataIsWallNode:\r\n      node.setAttribute(attr, value);\r\n      break;\r\n    case dataIsBombNode:\r\n      node.setAttribute(attr, value);\r\n      break;\r\n    case dataIsGapNode:\r\n      node.setAttribute(attr, value);\r\n      break;\r\n    default:\r\n      node.setAttribute('', '');\r\n  }\r\n};\r\n\r\n// add visited nodes\r\nexport const addVisitedNode = (node: HTMLDivElement, toTarget: string, idx: number) => {\r\n  const nodeH = node;\r\n  if (toTarget === 'BOMB') {\r\n    visitedNodesBomb.push(idx);\r\n    nodeH.style.backgroundColor = visitedNodeColorToBomb;\r\n  } else {\r\n    visitedNodesTarget.push(idx);\r\n    nodeH.style.backgroundColor = visitedNodeColor;\r\n  }\r\n};\r\n\r\n// add path node\r\nexport const addPathNode = (node: HTMLDivElement, idx: number) => {\r\n  pathNodes.push(idx);\r\n  const nodeH = node;\r\n  // nodeH.classList.remove('pf-grid-node-border-color');\r\n  nodeH.style.backgroundColor = shortestPathNodeColor;\r\n};\r\n\r\n// add gapNode\r\nexport const addGapNode = (node: HTMLDivElement, idx: number) => {\r\n  gapNodes.push(idx);\r\n  setAttr(node, dataIsGapNode, 'true');\r\n};\r\n\r\n// add remove wall node\r\nexport const addRemoveWallNode = (node: HTMLDivElement, idx: number) => {\r\n  const isStartNode = getAttr(node, dataIsStartNode);\r\n  const isTargetNode = getAttr(node, dataIsTargetNode);\r\n  const isWallNode = getAttr(node, dataIsWallNode);\r\n  const isBombNode = getAttr(node, dataIsBombNode);\r\n  const nodeH = node;\r\n\r\n  if (isStartNode === 'true') { nodeInfoStart.isWallNode = 'true'; return; }\r\n  if (isTargetNode === 'true') { nodeInfoTarget.isWallNode = 'true'; return; }\r\n  if (isBombNode === 'true') { nodeInfoBomb.isWallNode = 'true'; return; }\r\n\r\n  if (isWallNode === 'true') {\r\n    const nodeIndex = wallNodes.indexOf(idx);\r\n    if (nodeIndex !== -1) wallNodes.splice(nodeIndex, 1);\r\n    nodeH.style.backgroundColor = transparent;\r\n    setAttr(nodeH, dataIsWallNode, 'false');\r\n    nodeH.classList.add('pf-grid-node-border-color');\r\n  } else {\r\n    wallNodes.push(idx);\r\n    nodeH.style.backgroundColor = wallNodeColor;\r\n    setAttr(nodeH, dataIsWallNode, 'true');\r\n    nodeH.classList.remove('pf-grid-node-border-color');\r\n  }\r\n};\r\n\r\n// make elements draggalbe start, target and bomb node\r\nexport const createDraggble = (\r\n  className: string,\r\n  nodeIndex: number,\r\n  noOfNodes: number,\r\n  nodes: HTMLDivElement[] | null,\r\n) => {\r\n  if (className === startNode) nodeInfoStart.index = nodeIndex;\r\n  if (className === targetNode) nodeInfoTarget.index = nodeIndex;\r\n  Draggable.create(`.${className}`, {\r\n    type: 'x,y',\r\n    bounds: '.pf-grid-node-holder',\r\n    inertia: true,\r\n    liveSnap: true,\r\n    snap: {\r\n      x(endValue) {\r\n        return Math.round(endValue / 25) * 25;\r\n      },\r\n      y(endValue) {\r\n        return Math.round(endValue / 25) * 25;\r\n      },\r\n    },\r\n    onPress() {\r\n      if (className === startNode) {\r\n        nodeInfo = JSON.parse(JSON.stringify(nodeInfoStart));\r\n        if (nodes !== null) setAttr(nodes[nodeInfo.index], dataIsStartNode, 'false');\r\n      }\r\n      if (className === targetNode) {\r\n        nodeInfo = JSON.parse(JSON.stringify(nodeInfoTarget));\r\n        if (nodes !== null) setAttr(nodes[nodeInfo.index], dataIsTargetNode, 'false');\r\n      }\r\n      if (className === bombNode) {\r\n        nodeInfo = JSON.parse(JSON.stringify(nodeInfoBomb));\r\n        if (nodes !== null) setAttr(nodes[nodeInfo.index], dataIsBombNode, 'false');\r\n      }\r\n      initialIndex = nodeInfo.index === -1 ? nodeIndex : nodeInfo.index;\r\n    },\r\n    onDrag() {\r\n      if (nodes === null) return;\r\n      if (nodeInfo.isWallNode === 'true') {\r\n        addRemoveWallNode(nodes[nodeInfo.index], nodeInfo.index);\r\n      }\r\n      calculateNodeNewIndex([initialIndex, noOfNodes, this.x, this.y]);\r\n\r\n      const node = nodes[nodeInfo.index];\r\n      const isStartNode = getAttr(node, dataIsStartNode);\r\n      const isTargetNode = getAttr(node, dataIsTargetNode);\r\n      const isWallNode = getAttr(node, dataIsWallNode);\r\n      const isBombNode = getAttr(node, dataIsBombNode);\r\n\r\n      nodeInfo.isWallNode = isWallNode;\r\n      if (isWallNode === 'true') addRemoveWallNode(node, nodeInfo.index);\r\n\r\n      // dragging startNode\r\n      if (className === startNode && isTargetNode === 'false' && isBombNode === 'false') {\r\n        nodeInfo.x = this.x;\r\n        nodeInfo.y = this.y;\r\n        prevIndex = nodeInfo.index;\r\n      }\r\n\r\n      // dragging tagetNode\r\n      if (className === targetNode && isStartNode === 'false' && isBombNode === 'false') {\r\n        nodeInfo.x = this.x;\r\n        nodeInfo.y = this.y;\r\n        prevIndex = nodeInfo.index;\r\n      }\r\n\r\n      // dragging bombNode\r\n      if (className === bombNode && isStartNode === 'false' && isTargetNode === 'false') {\r\n        nodeInfo.x = this.x;\r\n        nodeInfo.y = this.y;\r\n        prevIndex = nodeInfo.index;\r\n      }\r\n    },\r\n    onDragEnd() {\r\n      if (nodes === null) return;\r\n      const isStartNode = getAttr(nodes[nodeInfo.index], dataIsStartNode);\r\n      const isTargetNode = getAttr(nodes[nodeInfo.index], dataIsTargetNode);\r\n      const isBombNode = getAttr(nodes[nodeInfo.index], dataIsBombNode);\r\n\r\n      // while dragging start node\r\n      // when the end position is occupied.\r\n      if (isStartNode === 'true' || isTargetNode === 'true' || isBombNode === 'true') {\r\n        // calculateNodeNewIndex([nodeInfo.index, noOfNodes, nodeInfo.x, nodeInfo.y]);\r\n        const isWallNode = getAttr(nodes[prevIndex], dataIsWallNode);\r\n        nodeInfo.isWallNode = isWallNode;\r\n        nodeInfo.index = prevIndex;\r\n        if (isWallNode === 'true') {\r\n          addRemoveWallNode(nodes[prevIndex], nodeInfo.index);\r\n        }\r\n\r\n        // TweenLite.to(`.${className}`, { x: nodeInfo.x, y: nodeInfo.y });\r\n        // gsap.to(`.${className}`, { x: nodeInfo.x, y: nodeInfo.y });\r\n      }\r\n\r\n      // dragging startNode\r\n      if (className === startNode) {\r\n        nodeInfoStart = JSON.parse(JSON.stringify(nodeInfo));\r\n        setAttr(nodes[initialIndex], dataIsStartNode, 'false');\r\n        setAttr(nodes[nodeInfo.index], dataIsStartNode, 'true');\r\n      }\r\n\r\n      // dragging tagetNode\r\n      if (className === targetNode) {\r\n        nodeInfoTarget = JSON.parse(JSON.stringify(nodeInfo));\r\n        setAttr(nodes[initialIndex], dataIsTargetNode, 'false');\r\n        setAttr(nodes[nodeInfo.index], dataIsTargetNode, 'true');\r\n      }\r\n\r\n      // dragging bombNode\r\n      if (className === bombNode) {\r\n        nodeInfoBomb = JSON.parse(JSON.stringify(nodeInfo));\r\n        setAttr(nodes[initialIndex], dataIsBombNode, 'false');\r\n        setAttr(nodes[nodeInfo.index], dataIsBombNode, 'true');\r\n      }\r\n\r\n      gsap.set(`.${className}`, { x: 0, y: 0 });\r\n      nodes[nodeInfo.index].appendChild(this.target);\r\n    },\r\n  });\r\n};\r\n","import {\r\n  dataIsBombNode, dataIsGapNode, dataIsStartNode, dataIsTargetNode,\r\n} from '../helperFunctions/customAttr';\r\nimport { addGapNode, getAttr } from '../helperFunctions/helperFunctions';\r\n\r\nconst randomNumber = (min: number, max: number) => Math.random() * (max - min + 1) + min;\r\nexport const randomIntFromInterval = (\r\n  min: number, max: number,\r\n) => Math.floor(randomNumber(min, max));\r\n\r\n// which way to bisect when making mazes\r\nexport const horizontal = 'horizontal';\r\nexport const vertical = 'vertical';\r\n\r\nexport const randomIndex = (length: number) => Math.floor(Math.random() * length);\r\n\r\n// vertically or horizontally\r\nexport const chooseOrientation = (height: number, width: number): string => {\r\n  if (width < height) return horizontal;\r\n  if (height < width) return vertical;\r\n  const orientation = [horizontal, vertical];\r\n  const randomIdx = randomIndex(orientation.length);\r\n  return orientation[randomIdx];\r\n};\r\n\r\n// timeouts\r\nlet timeouts: number[] = [];\r\n\r\nexport const clearTimeouts = () => {\r\n  timeouts.forEach((timeout: number) => {\r\n    clearTimeout(timeout);\r\n  });\r\n};\r\n\r\nexport const pushTimer = (timer: number) => {\r\n  timeouts.push(timer);\r\n};\r\n\r\nexport const resetTimeouts = (newTimeouts: number[]) => {\r\n  timeouts = newTimeouts;\r\n};\r\n\r\n// export const consoleLogTimeouts = () => {\r\n//   console.log(timeouts);\r\n// };\r\n\r\n// for recursive division\r\nexport interface offSetType {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n// divide\r\nexport const divide = (\r\n  nodes: HTMLDivElement[], noOfNodes: number,\r\n  startPos: number, length: number,\r\n  orientation: string, animations: number[], offset: offSetType,\r\n) => {\r\n  const tempAnimations: number[] = [];\r\n  let isGapIndex = false;\r\n  let gapIndex = 0;\r\n  const { x, y } = offset;\r\n  for (let i = 1; i < length + 1; i += 1) {\r\n    const nodeIdx = orientation === horizontal ? ((startPos + y) * noOfNodes) + i + x\r\n      : ((i + y) * noOfNodes) + startPos + x;\r\n    const isStartNode = getAttr(nodes[nodeIdx], dataIsStartNode);\r\n    const isTargetNode = getAttr(nodes[nodeIdx], dataIsTargetNode);\r\n    const isBombNode = getAttr(nodes[nodeIdx], dataIsBombNode);\r\n    animations.push(nodeIdx);\r\n    if (isStartNode === 'false' && isTargetNode === 'false' && isBombNode === 'false') {\r\n      tempAnimations.push(nodeIdx);\r\n    }\r\n\r\n    if (i === 1) {\r\n      const nodeIndex = orientation === horizontal ? nodeIdx - 1 : nodeIdx - noOfNodes;\r\n      const isGapNode = typeof nodes[nodeIndex] === 'undefined' ? false\r\n        : getAttr(nodes[nodeIndex], dataIsGapNode);\r\n      if (isGapNode === 'true') {\r\n        isGapIndex = true;\r\n        gapIndex = nodeIndex;\r\n      }\r\n      if (gapIndex !== 0) {\r\n        const animationsNodeIndex = animations.indexOf(nodeIdx);\r\n        if (animationsNodeIndex !== -1) animations.splice(animationsNodeIndex, 1);\r\n        addGapNode(nodes[nodeIdx], nodeIdx);\r\n        gapIndex = 0;\r\n      }\r\n    }\r\n\r\n    if (i === length) {\r\n      const nodeIndex = orientation === horizontal ? nodeIdx + 1 : nodeIdx + noOfNodes;\r\n      const isGapNode = typeof nodes[nodeIndex] === 'undefined' ? false\r\n        : getAttr(nodes[nodeIndex], dataIsGapNode);\r\n      if (isGapNode === 'true') {\r\n        isGapIndex = true;\r\n        gapIndex = nodeIndex;\r\n      }\r\n      if (gapIndex !== 0) {\r\n        const animationsNodeIndex = animations.indexOf(nodeIdx);\r\n        if (animationsNodeIndex !== -1) animations.splice(animationsNodeIndex, 1);\r\n        addGapNode(nodes[nodeIdx], nodeIdx);\r\n        gapIndex = 0;\r\n      }\r\n    }\r\n\r\n    if (i === length && !isGapIndex) {\r\n      const randomIdx = randomIndex(tempAnimations.length);\r\n      const nodeIndex = tempAnimations[randomIdx];\r\n      tempAnimations.splice(randomIdx, 1);\r\n      const animationsNodeIndex = animations.indexOf(nodeIndex);\r\n      if (animationsNodeIndex !== -1) animations.splice(animationsNodeIndex, 1);\r\n      addGapNode(nodes[nodeIndex], nodeIndex);\r\n    }\r\n  }\r\n};\r\n\r\n// get startXY for recursive division\r\nexport const getStartXY = (length: number, type: string) => {\r\n  const startXOptions = [];\r\n  const startYOptions = [];\r\n  for (let i = 2; i < length; i += 1) {\r\n    if (type === 'X') {\r\n      startXOptions.push(i);\r\n    }\r\n    if (type === 'Y') {\r\n      startYOptions.push(i);\r\n    }\r\n  }\r\n\r\n  if (type === 'X' && startXOptions.length !== 0) {\r\n    const startXIdx = randomIndex(startXOptions.length);\r\n    return startXOptions[startXIdx];\r\n  }\r\n  const startYIdx = randomIndex(startYOptions.length);\r\n  return startYOptions[startYIdx];\r\n};\r\n","import {\r\n  dataIsFirstCol, dataIsFirstRow, dataIsLastCol, dataIsLastRow,\r\n} from '../helperFunctions/customAttr';\r\nimport { addPathNode, addVisitedNode, getAttr } from '../helperFunctions/helperFunctions';\r\nimport { pushTimer, resetTimeouts } from '../mazesAndPatterns/mazesAndPatternsHelper';\r\n\r\nexport const algorithms = [\r\n  'A* Search', 'Bidirectional Algorithm', 'Breadth-first Search',\r\n  'Depth-first Search', 'Dijkstra\\'s Algorithm',\r\n];\r\n\r\nconst pathfindingAlgorithmsOptions = () => {\r\n  const pathfindingAlgorithms = [\r\n    { key: algorithms[0], text: algorithms[0], value: algorithms[0] },\r\n    { key: algorithms[1], text: algorithms[1], value: algorithms[1] },\r\n    { key: algorithms[2], text: algorithms[2], value: algorithms[2] },\r\n    { key: algorithms[3], text: algorithms[3], value: algorithms[3] },\r\n    { key: algorithms[4], text: algorithms[4], value: algorithms[4] },\r\n  ];\r\n\r\n  return pathfindingAlgorithms;\r\n};\r\n\r\n// eslint-disable-next-line import/no-mutable-exports\r\nexport let timer = 100;\r\n\r\nexport const setTimer = (time: number) => {\r\n  timer = time;\r\n};\r\n\r\nexport const size = (map: Map<any, any>) => {\r\n  let c = 0;\r\n  map.forEach(() => { c += 1; });\r\n  return c;\r\n};\r\n\r\nconst isNodeInFirstCol = (node: HTMLDivElement) => getAttr(node, dataIsFirstCol);\r\nconst isNodeInLastCol = (node: HTMLDivElement) => getAttr(node, dataIsLastCol);\r\nconst isNodeInFirstRow = (node: HTMLDivElement) => getAttr(node, dataIsFirstRow);\r\nconst isNodeInLastRow = (node: HTMLDivElement) => getAttr(node, dataIsLastRow);\r\n\r\nexport const conditionUp = (node: HTMLDivElement) => (\r\n  (isNodeInFirstCol(node) === 'false' && isNodeInFirstRow(node) === 'false')\r\n  || (isNodeInLastCol(node) === 'false' && isNodeInFirstRow(node) === 'false')\r\n);\r\n\r\nexport const conditionDown = (node: HTMLDivElement) => (\r\n  (isNodeInFirstCol(node) === 'false' && isNodeInLastRow(node) === 'false')\r\n  || (isNodeInLastCol(node) === 'false' && isNodeInLastRow(node) === 'false')\r\n);\r\n\r\nexport const conditionLeft = (node: HTMLDivElement) => isNodeInFirstCol(node) === 'false';\r\n\r\nexport const conditionRight = (node: HTMLDivElement) => isNodeInLastCol(node) === 'false';\r\n\r\nexport const findOptimalPath = (\r\n  auxPath: number[],\r\n  path: number[],\r\n  start: number,\r\n  target: number,\r\n  closedNodes: Map<number, any>,\r\n  reverseNodes: boolean,\r\n) => {\r\n  if (start === target) {\r\n    if (reverseNodes) {\r\n      for (let i = 0; i < auxPath.length; i += 1) {\r\n        path.push(auxPath[i]);\r\n      }\r\n    } else {\r\n      for (let i = auxPath.length - 1; i >= 0; i -= 1) {\r\n        path.push(auxPath[i]);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n  const node = closedNodes.get(target);\r\n  auxPath.unshift(node!!.nodeIdxParent);\r\n  findOptimalPath(auxPath, path, start, node!!.nodeIdxParent, closedNodes, reverseNodes);\r\n};\r\n\r\nconst animatePath = (\r\n  nodes: HTMLDivElement[], animations: number[], hideCover: () => void,\r\n) => {\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    const timerH = window.setTimeout(() => {\r\n      const nodeIdx = animations[i];\r\n      addPathNode(nodes[nodeIdx], nodeIdx);\r\n      if (i === animations.length - 1) hideCover();\r\n    }, i * timer);\r\n    pushTimer(timerH);\r\n  }\r\n};\r\n\r\nconst animateTargetNode = (\r\n  nodes: HTMLDivElement[], animations: number[], pathAniamtions: number[],\r\n  hideCover: () => void, showError: () => void, isPathFound: boolean,\r\n) => {\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    const timerH = window.setTimeout(() => {\r\n      const nodeIdx = animations[i];\r\n      addVisitedNode(nodes[nodeIdx], 'target', nodeIdx);\r\n      if (i === animations.length - 1 && !isPathFound) { showError(); hideCover(); }\r\n      if (i === animations.length - 1 && isPathFound) {\r\n        animatePath(nodes, pathAniamtions, hideCover);\r\n      }\r\n    }, i * timer);\r\n\r\n    pushTimer(timerH);\r\n  }\r\n};\r\n\r\nexport const animateBombNode = (\r\n  nodes: HTMLDivElement[], bombAnimations: number[], targetAnimations: number[],\r\n  pathAnimations: number[], hideCover: () => void, showError: () => void,\r\n  bombNode: number, isPathFound: boolean, isBombPathFound: boolean,\r\n) => {\r\n  resetTimeouts([]);\r\n  if (bombNode === -1) {\r\n    animateTargetNode(nodes, targetAnimations, pathAnimations, hideCover, showError, isPathFound);\r\n  } else {\r\n    for (let i = 0; i < bombAnimations.length; i += 1) {\r\n      const timerH = window.setTimeout(() => {\r\n        const nodeIdx = bombAnimations[i];\r\n        addVisitedNode(nodes[nodeIdx], 'BOMB', nodeIdx);\r\n        if (i === bombAnimations.length - 1 && !isBombPathFound) { showError(); hideCover(); }\r\n        if (i === bombAnimations.length - 1 && isBombPathFound) {\r\n          animateTargetNode(\r\n            nodes, targetAnimations, pathAnimations, hideCover, showError, isPathFound,\r\n          );\r\n        }\r\n      }, i * timer);\r\n      pushTimer(timerH);\r\n    }\r\n  }\r\n};\r\n\r\nexport default pathfindingAlgorithmsOptions;\r\n","export const mazesKeys = [\r\n  'None', 'Basic Random Maze', 'Recursive Division',\r\n  'Recursive Division (horizontal skew)', 'Recursive Division (vertical skew)', 'Simple Stair Pattern',\r\n];\r\n\r\nexport interface mazesType {\r\n  key: string;\r\n  text: string;\r\n  idx: number;\r\n}\r\n\r\nconst mazesAndPatternsOptions = () => {\r\n  const mazesAndPatterns: mazesType[] = [];\r\n  mazesKeys.forEach((name: string, index: number) => {\r\n    mazesAndPatterns.push({ key: name, text: name, idx: index });\r\n  });\r\n\r\n  return mazesAndPatterns;\r\n};\r\n\r\nexport default mazesAndPatternsOptions;\r\n","import { RefObject } from 'react';\r\n\r\n// dropdown arrow direction\r\ninterface ArrowDirection {\r\n  direction: string;\r\n}\r\nexport const arrowDown: ArrowDirection = { direction: 'down' };\r\nexport const arrowUp: ArrowDirection = { direction: 'up' };\r\n\r\n// add nav nav type for the mazes option\r\n// active option not working when using same ref\r\n// nav type\r\nexport const topNav = 'top_nav';\r\nexport const bottomNav = 'bottom_nav';\r\n\r\n// Nav.tsx\r\nexport interface NavProps {\r\n  navType: string;\r\n  arrowDirection: ArrowDirection | string;\r\n  mazesPatternButtonsRef: Array<RefObject<Array<HTMLButtonElement>>>;\r\n  currentActiveMazeAndPattern: number\r\n  // eslint-disable-next-line no-unused-vars\r\n  animateMazesAndPatterns: (maze: string, idx: number) => void;\r\n}\r\n\r\n// top Nav props\r\nexport interface TopNavProps extends NavProps {\r\n  nodes: RefObject<HTMLDivElement[]>;\r\n  noOfRows: number;\r\n  noOfNodes: number;\r\n  sideNav: RefObject<HTMLDivElement>;\r\n  showCover: () => void;\r\n  hideCover: () => void;\r\n}\r\n\r\n// side nav props\r\ninterface SideNavProps {\r\n  top: number;\r\n  height: number;\r\n}\r\n\r\n// open side nav props\r\nexport interface OpenSideNavProps extends SideNavProps {\r\n  sideNavRef: RefObject<HTMLDivElement> | null;\r\n}\r\n\r\n// side nav div props\r\nexport interface SideNavDivProps extends SideNavProps {\r\n  addBomb: () => void;\r\n  resetBoard: () => void;\r\n  clearPathNodes: () => void;\r\n  clearWalls: () => void;\r\n  speedSideNavRef: RefObject<HTMLDivElement> | null;\r\n  openSideNavRef: RefObject<HTMLDivElement> | null;\r\n}\r\n","import { Menu } from 'semantic-ui-react';\r\nimport { Dropdown, DropdownButton } from 'react-bootstrap';\r\nimport mazesAndPatternsOptions, { mazesType } from '../mazesAndPatterns/mazesAndPatternsOptions';\r\nimport { NavProps, arrowDown, topNav } from '../helperFunctions/props';\r\n\r\nfunction Nav(props: NavProps) {\r\n  const {\r\n    navType, arrowDirection, animateMazesAndPatterns,\r\n    mazesPatternButtonsRef, currentActiveMazeAndPattern,\r\n  } = props;\r\n  // v for variable :-)\r\n  const mazesAndPatternsOptionsV = mazesAndPatternsOptions();\r\n\r\n  return (\r\n    <>\r\n      <Menu.Item href=\"/\" header>Pathfinding Visualizer</Menu.Item>\r\n      <Menu.Item>\r\n        <DropdownButton\r\n          drop={arrowDirection === arrowDown ? 'down' : 'up'}\r\n          id=\"dropdown-basic-button\"\r\n          title=\"Mazes & Patterns\"\r\n        >\r\n          {mazesAndPatternsOptionsV.map((maze: mazesType, idx: number) => (\r\n            <Dropdown.Item\r\n              ref={(elem: HTMLButtonElement) => {\r\n                if (navType === topNav) {\r\n                  mazesPatternButtonsRef[0].current!![maze.idx] = elem;\r\n                } else {\r\n                  mazesPatternButtonsRef[1].current!![maze.idx] = elem;\r\n                }\r\n              }}\r\n              className={idx === currentActiveMazeAndPattern ? 'active' : ''}\r\n              as=\"button\"\r\n              key={maze.key}\r\n              onClick={() => { animateMazesAndPatterns(maze.key, maze.idx); }}\r\n            >\r\n              {maze.text}\r\n            </Dropdown.Item>\r\n          ))}\r\n        </DropdownButton>\r\n      </Menu.Item>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Nav;\r\n","import { transparent } from './helperFunctions/color';\r\nimport {\r\n  dataIsStartNode, dataIsTargetNode, dataIsWallNode,\r\n  dataIsBombNode, dataIdx, dataIsGapNode,\r\n} from './helperFunctions/customAttr';\r\nimport {\r\n  bombNode, createDraggble, getNodeStartInfo, getNodeTargetInfo, getNodeBombInfo,\r\n  wallNodes, addRemoveWallNode, getAttr, setAttr, getDarkMode, gapNodes,\r\n  pathNodes, visitedNodesBomb, visitedNodesTarget,\r\n} from './helperFunctions/helperFunctions';\r\nimport {\r\n  NodeType, RowsType, RowType,\r\n} from './helperFunctions/types';\r\n\r\nlet nodeIdx = 0;\r\nlet bombIndex = -1;\r\nlet i: HTMLElement | null = null;\r\nlet typeOfSearchAlgorithm = '';\r\n\r\n// set\r\nexport const setTtypeOfSearchAlgorithm = (type: string) => {\r\n  typeOfSearchAlgorithm = type;\r\n};\r\n\r\n// get bombIndex\r\nexport const getBombIndex = () => bombIndex;\r\n\r\n// generate a pfGrid\r\nexport const generatePfGrid = (noOfRows: number, noOfNodes: number): RowsType => {\r\n  bombIndex = -1;\r\n  i?.remove();\r\n\r\n  const rows: RowsType = [];\r\n  const startRow = Math.floor(noOfRows / 2);\r\n  // H for Helper\r\n  const startNodeH = Math.floor(noOfNodes / 4);\r\n  for (let row = 0; row < noOfRows; row += 1) {\r\n    const currentRow: RowType = [];\r\n    for (let node = 0; node < noOfNodes; node += 1) {\r\n      // column is equal to the current node number in a row\r\n      const col = node;\r\n      const currentNode: NodeType = {\r\n        row,\r\n        col,\r\n        isNodeInFirstCol: col === 0,\r\n        isNodeInLastCol: col === noOfNodes - 1,\r\n        isNodeInFirstRow: row === 0,\r\n        isNodeInLastRow: row === noOfRows - 1,\r\n        isStartNode: row === startRow && col === startNodeH,\r\n        isTargetNode: row === startRow && col === noOfNodes - startNodeH - 1,\r\n        isWallNode: false,\r\n        isBombNode: false,\r\n        idx: nodeIdx,\r\n      };\r\n      nodeIdx += 1;\r\n      currentRow.push(currentNode);\r\n    }\r\n    rows.push(currentRow);\r\n  }\r\n  nodeIdx = 0;\r\n  return rows;\r\n};\r\n\r\n// toggle wall nodes\r\nexport const getNewPfGridWithWallToggled = (\r\n  // rows: RowsType,\r\n  // row: number,\r\n  // col: number,\r\n  elem: HTMLElement,\r\n  nodes: HTMLDivElement[],\r\n) => {\r\n  // updating state makes app to slow down\r\n  // const newGrid = rows.slice();\r\n  // const node = newGrid[row][col];\r\n  // const newNode = {\r\n  //   ...node,\r\n  //   isWallNode: !node.isWallNode,\r\n  // };\r\n  // newGrid[row][col] = newNode;\r\n  // setPfgridRows(newGrid);\r\n  const className = elem.classList;\r\n  if (!className.contains('pf-grid-node')) return;\r\n\r\n  const idx = getAttr(elem as HTMLDivElement, dataIdx) as unknown as number;\r\n  const node = nodes[idx];\r\n  const isStartNode = getAttr(node, dataIsStartNode);\r\n  const isTargetNode = getAttr(node, dataIsTargetNode);\r\n  const isBombNode = getAttr(node, dataIsBombNode);\r\n\r\n  if (isStartNode === 'true' || isTargetNode === 'true' || isBombNode === 'true') return;\r\n\r\n  // this results to a bug where if (isWallNode) means if isWallNode is false\r\n  // and if (!isWallNode) is isWallNode is true confusion\r\n  // if (isWallNode) {\r\n  //   console.log(999);\r\n  // } else {\r\n  //   console.log(111);\r\n  // }\r\n  addRemoveWallNode(node, idx);\r\n};\r\n\r\n// clear visited nodes\r\nconst clearVisitedNodes = (nodes: HTMLDivElement[]) => {\r\n  visitedNodesBomb.forEach((idx: number) => {\r\n    const node: HTMLDivElement | null = nodes[idx];\r\n    const isWallNode = getAttr(node, dataIsWallNode);\r\n    if (node !== null && isWallNode === 'false') node.style.backgroundColor = transparent;\r\n  });\r\n  visitedNodesTarget.forEach((idx: number) => {\r\n    const node: HTMLDivElement | null = nodes[idx];\r\n    const isWallNode = getAttr(node, dataIsWallNode);\r\n    if (node !== null && isWallNode === 'false') node.style.backgroundColor = transparent;\r\n  });\r\n  visitedNodesBomb.length = 0;\r\n  visitedNodesTarget.length = 0;\r\n};\r\n\r\n// clear path nodes\r\nexport const clearPathNodes = (nodes: HTMLDivElement[]) => {\r\n  clearVisitedNodes(nodes);\r\n  pathNodes.forEach((idx: number) => {\r\n    const node: HTMLDivElement | null = nodes[idx];\r\n    const isWallNode = getAttr(node, dataIsWallNode);\r\n    if (node !== null && isWallNode === 'false') {\r\n      node.style.backgroundColor = transparent;\r\n      node.classList.add('pf-grid-node-border-color');\r\n    }\r\n  });\r\n  pathNodes.length = 0;\r\n};\r\n\r\n// clear gap nodes\r\nconst clearGapNodes = (nodes: HTMLDivElement[]) => {\r\n  gapNodes.forEach((idx: number) => {\r\n    const node: HTMLDivElement | null = nodes[idx];\r\n    if (node !== null) setAttr(node, dataIsGapNode, 'false');\r\n  });\r\n  gapNodes.length = 0;\r\n};\r\n\r\n// clear wall nodes\r\nexport const clearWalls = (nodes: HTMLDivElement[], resetMazesAndPatterns: () => void) => {\r\n  // if (wallNodes.length === 0) return;\r\n  clearPathNodes(nodes);\r\n  clearGapNodes(nodes);\r\n  resetMazesAndPatterns();\r\n  getNodeStartInfo().isWallNode = 'false';\r\n  getNodeTargetInfo().isWallNode = 'false';\r\n  getNodeBombInfo().isWallNode = 'false';\r\n  wallNodes.forEach((idx: number) => {\r\n    const node: HTMLDivElement | null = nodes[idx];\r\n    if (node !== null) {\r\n      node.style.backgroundColor = transparent;\r\n      setAttr(node, dataIsWallNode, 'false');\r\n      node.classList.add('pf-grid-node-border-color');\r\n    }\r\n  });\r\n  wallNodes.length = 0;\r\n};\r\n\r\nexport const resetBoard = (\r\n  nodes: HTMLDivElement[], noOfRows: number, noOfNodes: number,\r\n  resetMazesAndPatterns: () => void, sideNav: HTMLDivElement | null,\r\n) => {\r\n  if (bombIndex !== -1) {\r\n    const sideNavAddBomb = sideNav?.children[0];\r\n    const addBombElem = sideNavAddBomb!!.children[1];\r\n    const newNode = nodes[getNodeBombInfo().index];\r\n    setAttr(newNode, dataIsBombNode, 'false');\r\n    i?.remove();\r\n    addBombElem.textContent = 'Add Bomb';\r\n    getNodeBombInfo().index = -1;\r\n    bombIndex = -1;\r\n  }\r\n\r\n  setAttr(nodes[getNodeStartInfo().index], dataIsStartNode, 'false');\r\n  setAttr(nodes[getNodeTargetInfo().index], dataIsTargetNode, 'false');\r\n  const startRow = Math.floor(noOfRows / 2);\r\n  // H for Helper\r\n  const startNodeH = Math.floor(noOfNodes / 4);\r\n  const startIdx = (noOfNodes * startRow) + startNodeH;\r\n  const targetIdx = (noOfNodes * startRow) + (noOfNodes - startNodeH - 1);\r\n  setAttr(nodes[startIdx], dataIsStartNode, 'true');\r\n  setAttr(nodes[targetIdx], dataIsTargetNode, 'true');\r\n\r\n  const startIcon = nodes[getNodeStartInfo().index].children[0];\r\n  const targetIcon = nodes[getNodeTargetInfo().index].children[0];\r\n  nodes[startIdx].appendChild(startIcon);\r\n  nodes[targetIdx].appendChild(targetIcon);\r\n  getNodeStartInfo().index = startIdx;\r\n  getNodeTargetInfo().index = targetIdx;\r\n\r\n  clearWalls(nodes, resetMazesAndPatterns);\r\n};\r\n\r\n// add bomb node\r\nexport const addBomb = (\r\n  noOfNodes: number,\r\n  nodes: HTMLDivElement[],\r\n  sideNav: HTMLDivElement | null,\r\n) => {\r\n  if (typeOfSearchAlgorithm === 'Bidirectional Algorithm') return;\r\n  const sideNavAddBomb = sideNav?.children[1];\r\n  const addBombElem = sideNavAddBomb!!.children[1];\r\n\r\n  // multiply by 2 for node to be in 3rd row\r\n  const row = noOfNodes * 2;\r\n  // node to be in the mid column\r\n  const column = Math.floor(noOfNodes / 2);\r\n  let nodeIndex = row + column;\r\n  let node = nodes[nodeIndex];\r\n\r\n  if (bombIndex === -1) {\r\n    // loop checking if its start or target node to skip the node\r\n    for (let j = 0; j < 2; j += 1) {\r\n      const isStartNode = getAttr(node, dataIsStartNode);\r\n      const isTargetNode = getAttr(node, dataIsTargetNode);\r\n      if (isStartNode === 'false' && isTargetNode === 'false') break;\r\n      nodeIndex += 1;\r\n      node = nodes[nodeIndex];\r\n    }\r\n    const isWallNode = getAttr(node, dataIsWallNode);\r\n    if (isWallNode === 'true') {\r\n      getNodeBombInfo().index = nodeIndex;\r\n      getNodeBombInfo().isWallNode = isWallNode;\r\n      addRemoveWallNode(node, nodeIndex);\r\n    } else {\r\n      getNodeBombInfo().index = nodeIndex;\r\n      getNodeBombInfo().isWallNode = isWallNode;\r\n    }\r\n    setAttr(node, dataIsBombNode, 'true');\r\n    i = document.createElement('i');\r\n    const addDarkMode = getDarkMode() ? 'inverted' : 'NA';\r\n    i.classList.add('large', 'bomb', 'icon', bombNode, addDarkMode);\r\n    node.appendChild(i);\r\n\r\n    createDraggble(bombNode, nodeIndex, noOfNodes, nodes);\r\n\r\n    addBombElem.textContent = 'Remove Bomb';\r\n    bombIndex = nodeIndex;\r\n  } else {\r\n    const newNode = nodes[getNodeBombInfo().index];\r\n    setAttr(newNode, dataIsBombNode, 'false');\r\n    if (getNodeBombInfo().isWallNode === 'true') addRemoveWallNode(newNode, getNodeBombInfo().index);\r\n    i?.remove();\r\n\r\n    addBombElem.textContent = 'Add Bomb';\r\n    bombIndex = -1;\r\n  }\r\n};\r\n","// A * search is weighted and guarantees shortest path\r\nimport { getBombIndex } from '../App.Functions';\r\nimport {\r\n  dataIsFirstCol, dataIsFirstRow, dataIsLastCol, dataIsLastRow, dataIsWallNode,\r\n} from '../helperFunctions/customAttr';\r\nimport {\r\n  addPathNode,\r\n  addVisitedNode, getAttr, getNodeBombInfo, getNodeStartInfo, getNodeTargetInfo,\r\n} from '../helperFunctions/helperFunctions';\r\nimport { pushTimer, resetTimeouts } from '../mazesAndPatterns/mazesAndPatternsHelper';\r\nimport { timer } from './pathfindingAlgorithmsOptions';\r\n\r\ninterface NodeType {\r\n  gCost: number,\r\n  hCost: number,\r\n  fCost: number,\r\n  nodeIdx: number,\r\n  nodeIdxParent: number\r\n}\r\n\r\nconst openNodes: Map<number, NodeType> = new Map();\r\nconst closedNodes: Map<number, NodeType> = new Map();\r\nlet startNode = getNodeStartInfo();\r\nlet targetNode = getNodeTargetInfo();\r\nlet bombNode = getBombIndex();\r\nlet stopLoop = false;\r\nlet isPathFound = true;\r\nlet isBombPathFound = true;\r\n// H for helper\r\nlet nodesH: HTMLDivElement[] = [];\r\nlet noOfNodesH: number = 0;\r\n\r\nconst size = (map: Map<any, any>) => {\r\n  let c = 0;\r\n  map.forEach(() => { c += 1; });\r\n  return c;\r\n};\r\n\r\nconst animatePath = (nodes: HTMLDivElement[], animations: number[], hideCover: () => void) => {\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    const timerH = window.setTimeout(() => {\r\n      const nodeIdx = animations[i];\r\n      addPathNode(nodes[nodeIdx], nodeIdx);\r\n      if (i === animations.length - 1) hideCover();\r\n    }, i * timer);\r\n    pushTimer(timerH);\r\n  }\r\n};\r\n\r\nconst animateTargetNode = (\r\n  nodes: HTMLDivElement[], animations: number[], pathAniamtions: number[],\r\n  hideCover: () => void, showError: () => void,\r\n) => {\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    // eslint-disable-next-line no-loop-func\r\n    const timerH = window.setTimeout(() => {\r\n      const nodeIdx = animations[i];\r\n      addVisitedNode(nodes[nodeIdx], 'target', nodeIdx);\r\n      if (i === animations.length - 1 && !isPathFound) { showError(); hideCover(); }\r\n      if (i === animations.length - 1 && isPathFound) {\r\n        animatePath(nodes, pathAniamtions, hideCover);\r\n      }\r\n    }, i * timer);\r\n\r\n    pushTimer(timerH);\r\n  }\r\n};\r\n\r\nconst animateBombNode = (\r\n  nodes: HTMLDivElement[], bombAnimations: number[], targetAnimations: number[],\r\n  pathAnimations: number[], hideCover: () => void, showError: () => void,\r\n) => {\r\n  resetTimeouts([]);\r\n  if (bombNode === -1) {\r\n    animateTargetNode(nodes, targetAnimations, pathAnimations, hideCover, showError);\r\n  } else {\r\n    for (let i = 0; i < bombAnimations.length; i += 1) {\r\n      // eslint-disable-next-line no-loop-func\r\n      const timerH = window.setTimeout(() => {\r\n        const nodeIdx = bombAnimations[i];\r\n        addVisitedNode(nodes[nodeIdx], 'BOMB', nodeIdx);\r\n        if (i === bombAnimations.length - 1 && !isBombPathFound) { showError(); hideCover(); }\r\n        if (i === bombAnimations.length - 1 && isBombPathFound) {\r\n          animateTargetNode(nodes, targetAnimations, pathAnimations, hideCover, showError);\r\n        }\r\n      }, i * timer);\r\n      pushTimer(timerH);\r\n    }\r\n  }\r\n};\r\n\r\nconst findOptimalPath = (\r\n  auxPath: number[],\r\n  path: number[],\r\n  start: number,\r\n  target: number,\r\n) => {\r\n  if (target === start) {\r\n    for (let i = 0; i < auxPath.length; i += 1) {\r\n      path.push(auxPath[i]);\r\n    }\r\n    return;\r\n  }\r\n  const node = closedNodes.get(target);\r\n  auxPath.unshift(node!!.nodeIdxParent);\r\n  findOptimalPath(auxPath, path, start, node!!.nodeIdxParent);\r\n};\r\n\r\nconst getNeighbour = (\r\n  condition: boolean, nodeIdx: number, parentCol: number, parentRow: number,\r\n  targetCol: number, targetRow: number, minFCostNode: NodeType, nodeNeighbours: NodeType[],\r\n) => {\r\n  if (condition) {\r\n    const isWallNode = getAttr(nodesH[nodeIdx], dataIsWallNode);\r\n    if (isWallNode === 'false') {\r\n      const row = Math.floor(nodeIdx / noOfNodesH);\r\n      const col = nodeIdx % noOfNodesH;\r\n      const gCost = Math.abs(col - parentCol) + Math.abs(row - parentRow) + minFCostNode.gCost;\r\n      const hCost = Math.abs(col - targetCol) + Math.abs(row - targetRow);\r\n      const fCost = gCost + hCost;\r\n      const node: NodeType = {\r\n        gCost,\r\n        hCost,\r\n        fCost,\r\n        nodeIdx,\r\n        nodeIdxParent: minFCostNode.nodeIdx,\r\n      };\r\n      nodeNeighbours.push(node);\r\n    }\r\n  }\r\n};\r\n\r\nconst findNode = (\r\n  nodeTarget: number, targetCol: number, targetRow: number,\r\n  animations: number[], targetType: string,\r\n) => {\r\n  while (!stopLoop) {\r\n    const minFCostArr: NodeType[] = [];\r\n    let minFCost = -1;\r\n    openNodes.forEach((node: NodeType) => {\r\n      if (minFCost === -1 || node.fCost < minFCost) minFCost = node.fCost;\r\n    });\r\n    openNodes.forEach((node: NodeType) => {\r\n      if (node.fCost === minFCost) minFCostArr.push(node);\r\n    });\r\n    let minFCostNode: NodeType = {\r\n      gCost: -1,\r\n      hCost: -1,\r\n      fCost: -1,\r\n      nodeIdx: -1,\r\n      nodeIdxParent: -1,\r\n    };\r\n\r\n    if (minFCostArr.length === 1) [minFCostNode] = minFCostArr;\r\n    if (minFCostArr.length > 1) {\r\n      let minHCost = -1;\r\n      minFCostArr.forEach((node: NodeType) => {\r\n        if (minHCost === -1) { minHCost = node.hCost; minFCostNode = node; }\r\n        if (node.hCost < minHCost) { minHCost = node.hCost; minFCostNode = node; }\r\n      });\r\n    }\r\n    closedNodes.set(minFCostNode.nodeIdx, minFCostNode);\r\n    openNodes.delete(minFCostNode.nodeIdx);\r\n\r\n    if (minFCostNode.nodeIdx === nodeTarget) { animations.push(minFCostNode.nodeIdx); break; }\r\n    if (size(openNodes) === 0 && minFCostArr.length === 0 && targetType === '') {\r\n      isPathFound = false;\r\n      break;\r\n    }\r\n    if (size(openNodes) === 0 && minFCostArr.length === 0 && targetType !== '') {\r\n      isBombPathFound = false;\r\n      break;\r\n    }\r\n\r\n    animations.push(minFCostNode.nodeIdx);\r\n    const isNodeInFirstCol = getAttr(nodesH[minFCostNode.nodeIdx], dataIsFirstCol);\r\n    const isNodeInLastCol = getAttr(nodesH[minFCostNode.nodeIdx], dataIsLastCol);\r\n    const isNodeInFirstRow = getAttr(nodesH[minFCostNode.nodeIdx], dataIsFirstRow);\r\n    const isNodeInLastRow = getAttr(nodesH[minFCostNode.nodeIdx], dataIsLastRow);\r\n    const nodeNeighbours: NodeType[] = [];\r\n\r\n    const parentRow = Math.floor(minFCostNode.nodeIdx / noOfNodesH);\r\n    const parentCol = minFCostNode.nodeIdx % noOfNodesH;\r\n\r\n    let condition = false;\r\n    let nodeIdx = 0;\r\n    // neighbour up\r\n    condition = (isNodeInFirstCol === 'false' && isNodeInFirstRow === 'false')\r\n    || (isNodeInLastCol === 'false' && isNodeInFirstRow === 'false');\r\n    nodeIdx = minFCostNode.nodeIdx - noOfNodesH;\r\n    getNeighbour(\r\n      condition, nodeIdx, parentCol, parentRow,\r\n      targetCol, targetRow, minFCostNode, nodeNeighbours,\r\n    );\r\n    // neighbour down\r\n    condition = (isNodeInFirstCol === 'false' && isNodeInLastRow === 'false')\r\n    || (isNodeInLastCol === 'false' && isNodeInLastRow === 'false');\r\n    nodeIdx = minFCostNode.nodeIdx + noOfNodesH;\r\n    getNeighbour(\r\n      condition, nodeIdx, parentCol, parentRow,\r\n      targetCol, targetRow, minFCostNode, nodeNeighbours,\r\n    );\r\n    // neighbour left\r\n    condition = isNodeInFirstCol === 'false';\r\n    nodeIdx = minFCostNode.nodeIdx - 1;\r\n    getNeighbour(\r\n      condition, nodeIdx, parentCol, parentRow,\r\n      targetCol, targetRow, minFCostNode, nodeNeighbours,\r\n    );\r\n    // neighbour right\r\n    condition = isNodeInLastCol === 'false';\r\n    nodeIdx = minFCostNode.nodeIdx + 1;\r\n    getNeighbour(\r\n      condition, nodeIdx, parentCol, parentRow,\r\n      targetCol, targetRow, minFCostNode, nodeNeighbours,\r\n    );\r\n    // neighbour top left\r\n    // condition = isNodeInFirstCol === 'false' && isNodeInFirstRow === 'false';\r\n    // nodeIdx = minFCostNode.nodeIdx - noOfNodes - 1;\r\n    // getNeighbour(\r\n    //   condition, nodeIdx, parentCol, parentRow,\r\n    //   targetCol, targetRow, minFCostNode, nodeNeighbours,\r\n    // );\r\n    // // neighbour top right\r\n    // condition = isNodeInLastCol === 'false' && isNodeInFirstRow === 'false';\r\n    // nodeIdx = minFCostNode.nodeIdx - noOfNodes + 1;\r\n    // getNeighbour(\r\n    //   condition, nodeIdx, parentCol, parentRow,\r\n    //   targetCol, targetRow, minFCostNode, nodeNeighbours,\r\n    // );\r\n    // // neighbour bottom left\r\n    // condition = isNodeInFirstCol === 'false' && isNodeInLastRow === 'false';\r\n    // nodeIdx = minFCostNode.nodeIdx + noOfNodes - 1;\r\n    // getNeighbour(\r\n    //   condition, nodeIdx, parentCol, parentRow,\r\n    //   targetCol, targetRow, minFCostNode, nodeNeighbours,\r\n    // );\r\n    // // neighbour bottom right\r\n    // condition = isNodeInLastCol === 'false' && isNodeInLastRow === 'false';\r\n    // nodeIdx = minFCostNode.nodeIdx + noOfNodes + 1;\r\n    // getNeighbour(\r\n    //   condition, nodeIdx, parentCol, parentRow,\r\n    //   targetCol, targetRow, minFCostNode, nodeNeighbours,\r\n    // );\r\n\r\n    nodeNeighbours.forEach((node: NodeType) => {\r\n      const isNeighbourInClosed = closedNodes.has(node.nodeIdx);\r\n      const isNeighbourInOpen = openNodes.has(node.nodeIdx);\r\n      if (!isNeighbourInClosed) {\r\n        if (isNeighbourInOpen && node.fCost < openNodes.get(node.nodeIdx)!!.fCost) {\r\n          const nodeH = openNodes.get(node.nodeIdx)!!;\r\n          nodeH.gCost = node.gCost;\r\n          nodeH.hCost = node.hCost;\r\n          nodeH.fCost = node.fCost;\r\n          nodeH.nodeIdxParent = minFCostNode.nodeIdx;\r\n        }\r\n\r\n        if (!isNeighbourInOpen) {\r\n          openNodes.set(node.nodeIdx, node);\r\n        }\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nconst aStar = (\r\n  nodes: HTMLDivElement[],\r\n  noOfRows: number,\r\n  noOfNodes: number,\r\n  hideCover: () => void,\r\n  showError: () => void,\r\n) => {\r\n  nodesH = nodes;\r\n  noOfNodesH = noOfNodes;\r\n  openNodes.clear();\r\n  closedNodes.clear();\r\n  startNode = getNodeStartInfo();\r\n  targetNode = getNodeTargetInfo();\r\n  bombNode = getBombIndex();\r\n  stopLoop = false;\r\n  isPathFound = true;\r\n  isBombPathFound = true;\r\n\r\n  const bombIndex = getNodeBombInfo();\r\n  const bombRow = Math.floor(bombIndex.index / noOfNodes);\r\n  const bombCol = bombIndex.index % noOfNodes;\r\n  const targetRow = Math.floor(targetNode.index / noOfNodes);\r\n  const targetCol = targetNode.index % noOfNodes;\r\n\r\n  const bombAnimations: number[] = [];\r\n  const targetAnimations: number[] = [];\r\n\r\n  openNodes.set(startNode.index, {\r\n    gCost: 0,\r\n    hCost: 0,\r\n    fCost: 0,\r\n    nodeIdx: startNode.index,\r\n    nodeIdxParent: 0,\r\n  });\r\n\r\n  const optimalPath: number[] = [];\r\n  if (bombNode !== -1) {\r\n    bombAnimations.push(startNode.index);\r\n    findNode(bombIndex.index, bombCol, bombRow, bombAnimations, 'B');\r\n    if (isBombPathFound) {\r\n      const auxPath = [];\r\n      auxPath.push(bombIndex.index);\r\n      findOptimalPath(auxPath, optimalPath, startNode.index, bombIndex.index);\r\n    }\r\n\r\n    openNodes.clear();\r\n    closedNodes.clear();\r\n    openNodes.set(bombIndex.index, {\r\n      gCost: 0,\r\n      hCost: 0,\r\n      fCost: 0,\r\n      nodeIdx: bombIndex.index,\r\n      nodeIdxParent: 0,\r\n    });\r\n\r\n    if (isBombPathFound) {\r\n      targetAnimations.push(bombIndex.index);\r\n      findNode(targetNode.index, targetCol, targetRow, targetAnimations, '');\r\n      if (isPathFound) {\r\n        const auxPath = [];\r\n        auxPath.push(targetNode.index);\r\n        findOptimalPath(auxPath, optimalPath, bombIndex.index, targetNode.index);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (bombNode === -1) {\r\n    targetAnimations.push(startNode.index);\r\n    findNode(targetNode.index, targetCol, targetRow, targetAnimations, '');\r\n    if (isPathFound) {\r\n      const auxPath = [];\r\n      auxPath.push(targetNode.index);\r\n      findOptimalPath(auxPath, optimalPath, startNode.index, targetNode.index);\r\n    }\r\n  }\r\n\r\n  animateBombNode(nodes, bombAnimations, targetAnimations, optimalPath, hideCover, showError);\r\n};\r\n\r\nexport default aStar;\r\n","// Bidirectional guarantees shortest path\r\nimport { dataIsWallNode } from '../helperFunctions/customAttr';\r\nimport {\r\n  addPathNode, addVisitedNode, getAttr, getNodeStartInfo, getNodeTargetInfo,\r\n} from '../helperFunctions/helperFunctions';\r\nimport { pushTimer, resetTimeouts } from '../mazesAndPatterns/mazesAndPatternsHelper';\r\nimport {\r\n  conditionDown, conditionLeft, conditionRight, conditionUp, findOptimalPath, size, timer,\r\n} from './pathfindingAlgorithmsOptions';\r\n\r\nconst openNodesStart: Map<number, NodeType> = new Map();\r\nconst openNodesTarget: Map<number, NodeType> = new Map();\r\nconst closedNodesStart: Map<number, NodeType> = new Map();\r\nconst closedNodesTarget: Map<number, NodeType> = new Map();\r\nlet isPathFound = true;\r\nlet startNode = getNodeStartInfo();\r\nlet targetNode = getNodeTargetInfo();\r\nlet targetRowOfStartNode = 0;\r\nlet targetColOfStartNode = 0;\r\nlet targetRowOfTargetNode = 0;\r\nlet targetColOfTargetNode = 0;\r\n// H for helper\r\nlet nodesH: HTMLDivElement[] = [];\r\nlet noOfNodesH: number = 0;\r\nlet meetingPoint = -1;\r\n\r\ninterface NodeType {\r\n  hCost: number,\r\n  nodeIdx: number,\r\n  nodeIdxParent: number\r\n}\r\n\r\nconst animatePath = (optimalPath: number[], nodes: HTMLDivElement[], hideCover: () => void) => {\r\n  if (isPathFound) {\r\n    resetTimeouts([]);\r\n    for (let i = 0; i < optimalPath.length; i += 1) {\r\n      const timerH = window.setTimeout(() => {\r\n        const nodeIdx = optimalPath[i];\r\n        addPathNode(nodes[nodeIdx], nodeIdx);\r\n        if (i === optimalPath.length - 1) hideCover();\r\n      }, i * timer);\r\n      pushTimer(timerH);\r\n    }\r\n  }\r\n};\r\n\r\nconst getMinimumHCostArr = (openNodes: Map<number, NodeType>, minHCostArr: NodeType[]) => {\r\n  let minFCost = -1;\r\n  openNodes.forEach((node: NodeType) => {\r\n    if (minFCost === -1 || node.hCost < minFCost) minFCost = node.hCost;\r\n  });\r\n  openNodes.forEach((node: NodeType) => {\r\n    if (node.hCost === minFCost) minHCostArr.push(node);\r\n  });\r\n};\r\n\r\nconst getMinimumHCost = (minHCostArr: NodeType[]): NodeType => {\r\n  let minHCostNode: NodeType = {\r\n    hCost: -1,\r\n    nodeIdx: -1,\r\n    nodeIdxParent: -1,\r\n  };\r\n  if (minHCostArr.length >= 1) [minHCostNode] = minHCostArr;\r\n\r\n  return minHCostNode;\r\n};\r\n\r\nconst getNodeNeighbour = (\r\n  condition: boolean, nodeIdx: number, targetCol: number,\r\n  targetRow: number, minHCostNode: NodeType, nodeNeighbours: NodeType[],\r\n) => {\r\n  if (condition) {\r\n    const isWallNode = getAttr(nodesH[nodeIdx], dataIsWallNode);\r\n    if (isWallNode === 'false') {\r\n      const row = Math.floor(nodeIdx / noOfNodesH);\r\n      const col = nodeIdx % noOfNodesH;\r\n      const hCost = Math.abs(col - targetCol) + Math.abs(row - targetRow);\r\n      const node: NodeType = {\r\n        hCost,\r\n        nodeIdx,\r\n        nodeIdxParent: minHCostNode.nodeIdx,\r\n      };\r\n      nodeNeighbours.push(node);\r\n    }\r\n  }\r\n};\r\n\r\nconst getNeighbour = (\r\n  animations: number[], minHCostNode: NodeType, targetCol: number, targetRow: number,\r\n  closedNodes: Map<number, NodeType>, openNodes: Map<number, NodeType>,\r\n) => {\r\n  animations.push(minHCostNode.nodeIdx);\r\n  const nodeNeighbours: NodeType[] = [];\r\n\r\n  let nodeIdx = 0;\r\n\r\n  // neighbour up\r\n  nodeIdx = minHCostNode.nodeIdx - noOfNodesH;\r\n  getNodeNeighbour(\r\n    conditionUp(nodesH[minHCostNode.nodeIdx]), nodeIdx,\r\n    targetCol, targetRow, minHCostNode, nodeNeighbours,\r\n  );\r\n\r\n  // neighbour down\r\n  nodeIdx = minHCostNode.nodeIdx + noOfNodesH;\r\n  getNodeNeighbour(\r\n    conditionDown(nodesH[minHCostNode.nodeIdx]), nodeIdx,\r\n    targetCol, targetRow, minHCostNode, nodeNeighbours,\r\n  );\r\n\r\n  // neighbour left\r\n  nodeIdx = minHCostNode.nodeIdx - 1;\r\n  getNodeNeighbour(\r\n    conditionLeft(nodesH[minHCostNode.nodeIdx]), nodeIdx,\r\n    targetCol, targetRow, minHCostNode, nodeNeighbours,\r\n  );\r\n\r\n  // neighbour right\r\n  nodeIdx = minHCostNode.nodeIdx + 1;\r\n  getNodeNeighbour(\r\n    conditionRight(nodesH[minHCostNode.nodeIdx]), nodeIdx,\r\n    targetCol, targetRow, minHCostNode, nodeNeighbours,\r\n  );\r\n\r\n  nodeNeighbours.forEach((node: NodeType) => {\r\n    const isNeighbourInClosed = closedNodes.has(node.nodeIdx);\r\n    const isNeighbourInOpen = openNodes.has(node.nodeIdx);\r\n    if (!isNeighbourInClosed) {\r\n      if (!isNeighbourInOpen) {\r\n        openNodes.set(node.nodeIdx, node);\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nconst bidirectionalSearchHelper = (animations: number[]) => {\r\n  const minHCostStartArr: NodeType[] = [];\r\n  const minHCostTargetArr: NodeType[] = [];\r\n  getMinimumHCostArr(openNodesStart, minHCostStartArr);\r\n  getMinimumHCostArr(openNodesTarget, minHCostTargetArr);\r\n\r\n  const minHCostNodeStart = getMinimumHCost(minHCostStartArr);\r\n  const minHCostNodeTarget = getMinimumHCost(minHCostTargetArr);\r\n\r\n  closedNodesStart.set(minHCostNodeStart.nodeIdx, minHCostNodeStart);\r\n  closedNodesTarget.set(minHCostNodeTarget.nodeIdx, minHCostNodeTarget);\r\n  openNodesStart.delete(minHCostNodeStart.nodeIdx);\r\n  openNodesTarget.delete(minHCostNodeTarget.nodeIdx);\r\n\r\n  const isInStartClosed = closedNodesStart.has(minHCostNodeTarget.nodeIdx);\r\n  const isInTargetClosed = closedNodesTarget.has(minHCostNodeStart.nodeIdx);\r\n\r\n  if (isInStartClosed) {\r\n    animations.push(minHCostNodeTarget.nodeIdx);\r\n    meetingPoint = minHCostNodeTarget.nodeIdx;\r\n    return;\r\n  }\r\n  if (isInTargetClosed) {\r\n    animations.push(minHCostNodeStart.nodeIdx);\r\n    meetingPoint = minHCostNodeStart.nodeIdx;\r\n    return;\r\n  }\r\n\r\n  if (\r\n    (size(openNodesStart) === 0 && minHCostStartArr.length === 0)\r\n    || (size(openNodesTarget) === 0 && minHCostTargetArr.length === 0)\r\n  ) { isPathFound = false; return; }\r\n\r\n  if (minHCostNodeStart.hCost !== -1) {\r\n    getNeighbour(\r\n      animations, minHCostNodeStart, targetColOfStartNode, targetRowOfStartNode,\r\n      closedNodesStart, openNodesStart,\r\n    );\r\n  }\r\n\r\n  if (minHCostNodeTarget.hCost !== -1) {\r\n    getNeighbour(\r\n      animations, minHCostNodeTarget, targetColOfTargetNode, targetRowOfTargetNode,\r\n      closedNodesTarget, openNodesTarget,\r\n    );\r\n  }\r\n\r\n  bidirectionalSearchHelper(animations);\r\n};\r\n\r\nconst bidirectionalSearch = (\r\n  nodes: HTMLDivElement[],\r\n  noOfRows: number,\r\n  noOfNodes: number,\r\n  hideCover: () => void,\r\n  showError: () => void,\r\n) => {\r\n  openNodesStart.clear();\r\n  openNodesTarget.clear();\r\n  closedNodesStart.clear();\r\n  closedNodesTarget.clear();\r\n  startNode = getNodeStartInfo();\r\n  targetNode = getNodeTargetInfo();\r\n  isPathFound = true;\r\n  nodesH = nodes;\r\n  noOfNodesH = noOfNodes;\r\n  meetingPoint = -1;\r\n\r\n  targetRowOfStartNode = Math.floor(targetNode.index / noOfNodes);\r\n  targetColOfStartNode = targetNode.index % noOfNodes;\r\n  targetRowOfTargetNode = Math.floor(startNode.index / noOfNodes);\r\n  targetColOfTargetNode = startNode.index % noOfNodes;\r\n\r\n  openNodesStart.set(startNode.index, {\r\n    hCost: 0,\r\n    nodeIdx: startNode.index,\r\n    nodeIdxParent: 0,\r\n  });\r\n  openNodesTarget.set(targetNode.index, {\r\n    hCost: 0,\r\n    nodeIdx: targetNode.index,\r\n    nodeIdxParent: 0,\r\n  });\r\n\r\n  const animations: number[] = [];\r\n  bidirectionalSearchHelper(animations);\r\n\r\n  const optimalPath: number[] = [];\r\n  if (isPathFound) {\r\n    findOptimalPath([], optimalPath, startNode.index, meetingPoint, closedNodesStart, true);\r\n    optimalPath.push(meetingPoint);\r\n    findOptimalPath([], optimalPath, targetNode.index, meetingPoint, closedNodesTarget, false);\r\n  }\r\n\r\n  resetTimeouts([]);\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    // eslint-disable-next-line no-loop-func\r\n    const timerH = window.setTimeout(() => {\r\n      const nodeIdx = animations[i];\r\n      addVisitedNode(nodes[nodeIdx], '', nodeIdx);\r\n      if (i === animations.length - 1 && !isPathFound) { showError(); hideCover(); }\r\n      if (i === animations.length - 1) animatePath(optimalPath, nodes, hideCover);\r\n    }, i * timer);\r\n    pushTimer(timerH);\r\n  }\r\n};\r\n\r\nexport default bidirectionalSearch;\r\n","// Dijkstra's guarantess shortest path\r\nimport { getBombIndex } from '../App.Functions';\r\nimport { dataIsWallNode } from '../helperFunctions/customAttr';\r\nimport {\r\n  getAttr, getNodeBombInfo, getNodeStartInfo, getNodeTargetInfo,\r\n} from '../helperFunctions/helperFunctions';\r\nimport {\r\n  animateBombNode,\r\n  conditionDown, conditionLeft, conditionRight, conditionUp, findOptimalPath, size,\r\n} from './pathfindingAlgorithmsOptions';\r\n\r\ninterface NodeType {\r\n  gCost: number,\r\n  nodeIdx: number,\r\n  nodeIdxParent: number\r\n}\r\n\r\nconst openNodes: Map<number, NodeType> = new Map();\r\nconst closedNodes: Map<number, NodeType> = new Map();\r\nlet startNode = getNodeStartInfo();\r\nlet targetNode = getNodeTargetInfo();\r\nlet bombNode = getBombIndex();\r\nlet isPathFound = true;\r\nlet isBombPathFound = true;\r\n// H for helper\r\nlet nodesH: HTMLDivElement[] = [];\r\nlet noOfNodesH: number = 0;\r\n\r\nconst getNeighbour = (\r\n  condition: boolean, nodeIdx: number, parentCol: number, parentRow: number,\r\n  minGCostNode: NodeType, nodeNeighbours: NodeType[],\r\n) => {\r\n  if (condition) {\r\n    const isWallNode = getAttr(nodesH[nodeIdx], dataIsWallNode);\r\n    if (isWallNode === 'false') {\r\n      const row = Math.floor(nodeIdx / noOfNodesH);\r\n      const col = nodeIdx % noOfNodesH;\r\n      const gCost = Math.abs(col - parentCol) + Math.abs(row - parentRow) + minGCostNode.gCost;\r\n      const node: NodeType = {\r\n        gCost,\r\n        nodeIdx,\r\n        nodeIdxParent: minGCostNode.nodeIdx,\r\n      };\r\n      nodeNeighbours.push(node);\r\n    }\r\n  }\r\n};\r\n\r\nconst dijkstrasHelper = (nodeTarget: number, animations: number[], targetType: string) => {\r\n  const minGCostArr: NodeType[] = [];\r\n  let minGCost = -1;\r\n  openNodes.forEach((node: NodeType) => {\r\n    if (minGCost === -1 || node.gCost < minGCost) minGCost = node.gCost;\r\n  });\r\n  openNodes.forEach((node: NodeType) => {\r\n    if (node.gCost === minGCost) minGCostArr.push(node);\r\n  });\r\n\r\n  let minGCostNode: NodeType = {\r\n    gCost: -1,\r\n    nodeIdx: -1,\r\n    nodeIdxParent: -1,\r\n  };\r\n  if (minGCostArr.length >= 1) [minGCostNode] = minGCostArr;\r\n  closedNodes.set(minGCostNode.nodeIdx, minGCostNode);\r\n  openNodes.delete(minGCostNode.nodeIdx);\r\n\r\n  if (minGCostNode.nodeIdx === nodeTarget) { animations.push(minGCostNode.nodeIdx); return; }\r\n  if (size(openNodes) === 0 && minGCostArr.length === 0 && targetType === '') {\r\n    isPathFound = false;\r\n    return;\r\n  }\r\n  if (size(openNodes) === 0 && minGCostArr.length === 0 && targetType !== '') {\r\n    isBombPathFound = false;\r\n    return;\r\n  }\r\n\r\n  animations.push(minGCostNode.nodeIdx);\r\n  const nodeNeighbours: NodeType[] = [];\r\n  const parentRow = Math.floor(minGCostNode.nodeIdx / noOfNodesH);\r\n  const parentCol = minGCostNode.nodeIdx % noOfNodesH;\r\n\r\n  let nodeIdx = 0;\r\n  // neighbour up\r\n  nodeIdx = minGCostNode.nodeIdx - noOfNodesH;\r\n  getNeighbour(\r\n    conditionUp(nodesH[minGCostNode.nodeIdx]), nodeIdx, parentCol,\r\n    parentRow, minGCostNode, nodeNeighbours,\r\n  );\r\n\r\n  // neighbour down\r\n  nodeIdx = minGCostNode.nodeIdx + noOfNodesH;\r\n  getNeighbour(\r\n    conditionDown(nodesH[minGCostNode.nodeIdx]), nodeIdx, parentCol,\r\n    parentRow, minGCostNode, nodeNeighbours,\r\n  );\r\n\r\n  // neighbour left\r\n  nodeIdx = minGCostNode.nodeIdx - 1;\r\n  getNeighbour(\r\n    conditionLeft(nodesH[minGCostNode.nodeIdx]), nodeIdx, parentCol,\r\n    parentRow, minGCostNode, nodeNeighbours,\r\n  );\r\n\r\n  // neighbour right\r\n  nodeIdx = minGCostNode.nodeIdx + 1;\r\n  getNeighbour(\r\n    conditionRight(nodesH[minGCostNode.nodeIdx]), nodeIdx, parentCol,\r\n    parentRow, minGCostNode, nodeNeighbours,\r\n  );\r\n\r\n  nodeNeighbours.forEach((node: NodeType) => {\r\n    const isNeighbourInClosed = closedNodes.has(node.nodeIdx);\r\n    const isNeighbourInOpen = openNodes.has(node.nodeIdx);\r\n    if (!isNeighbourInClosed) {\r\n      if (isNeighbourInOpen && node.gCost < openNodes.get(node.nodeIdx)!!.gCost) {\r\n        const nodeH = openNodes.get(node.nodeIdx)!!;\r\n        nodeH.gCost = node.gCost;\r\n        nodeH.nodeIdxParent = minGCostNode.nodeIdx;\r\n      }\r\n\r\n      if (!isNeighbourInOpen) {\r\n        openNodes.set(node.nodeIdx, node);\r\n      }\r\n    }\r\n  });\r\n\r\n  dijkstrasHelper(nodeTarget, animations, targetType);\r\n};\r\n\r\nconst dijkstras = (\r\n  nodes: HTMLDivElement[],\r\n  noOfRows: number,\r\n  noOfNodes: number,\r\n  hideCover: () => void,\r\n  showError: () => void,\r\n) => {\r\n  nodesH = nodes;\r\n  noOfNodesH = noOfNodes;\r\n  openNodes.clear();\r\n  closedNodes.clear();\r\n  startNode = getNodeStartInfo();\r\n  targetNode = getNodeTargetInfo();\r\n  bombNode = getBombIndex();\r\n  isPathFound = true;\r\n  isBombPathFound = true;\r\n\r\n  const bombIndex = getNodeBombInfo();\r\n  const bombAnimations: number[] = [];\r\n  const targetAnimations: number[] = [];\r\n  const optimalPath: number[] = [];\r\n\r\n  openNodes.set(startNode.index, {\r\n    gCost: 0,\r\n    nodeIdx: startNode.index,\r\n    nodeIdxParent: 0,\r\n  });\r\n\r\n  if (bombNode !== -1) {\r\n    dijkstrasHelper(bombIndex.index, bombAnimations, 'B');\r\n    if (isBombPathFound) {\r\n      const auxPath = [];\r\n      auxPath.push(bombIndex.index);\r\n      findOptimalPath(auxPath, optimalPath, startNode.index, bombIndex.index, closedNodes, true);\r\n    }\r\n\r\n    openNodes.clear();\r\n    closedNodes.clear();\r\n    openNodes.set(bombIndex.index, {\r\n      gCost: 0,\r\n      nodeIdx: bombIndex.index,\r\n      nodeIdxParent: 0,\r\n    });\r\n\r\n    if (isBombPathFound) {\r\n      dijkstrasHelper(targetNode.index, targetAnimations, '');\r\n      if (isPathFound) {\r\n        const auxPath = [];\r\n        auxPath.push(targetNode.index);\r\n        findOptimalPath(auxPath, optimalPath, bombIndex.index, targetNode.index, closedNodes, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (bombNode === -1) {\r\n    dijkstrasHelper(targetNode.index, targetAnimations, '');\r\n    if (isPathFound) {\r\n      const auxPath = [];\r\n      auxPath.push(targetNode.index);\r\n      findOptimalPath(auxPath, optimalPath, startNode.index, targetNode.index, closedNodes, true);\r\n    }\r\n  }\r\n\r\n  animateBombNode(\r\n    nodes, bombAnimations, targetAnimations, optimalPath,\r\n    hideCover, showError, bombNode, isPathFound, isBombPathFound,\r\n  );\r\n};\r\n\r\nexport default dijkstras;\r\n","// Breadth-first search\r\nimport { getBombIndex } from '../App.Functions';\r\nimport { dataIsWallNode } from '../helperFunctions/customAttr';\r\nimport {\r\n  getAttr, getNodeBombInfo, getNodeStartInfo, getNodeTargetInfo,\r\n} from '../helperFunctions/helperFunctions';\r\nimport {\r\n  animateBombNode,\r\n  conditionDown, conditionLeft, conditionRight, conditionUp, findOptimalPath,\r\n} from './pathfindingAlgorithmsOptions';\r\n\r\ninterface NodeType {\r\n  nodeIdx: number,\r\n  nodeIdxParent: number\r\n}\r\n\r\nconst openNodes: Map<number, NodeType> = new Map();\r\nconst closedNodes: Map<number, NodeType> = new Map();\r\nlet startNode = getNodeStartInfo();\r\nlet targetNode = getNodeTargetInfo();\r\nlet bombNode = getBombIndex();\r\nlet isPathFound = true;\r\nlet isBombPathFound = true;\r\n// H for helper\r\nlet nodesH: HTMLDivElement[] = [];\r\nlet noOfNodesH: number = 0;\r\n\r\nconst getNeighbour = (\r\n  condition: boolean, nodeIdx: number,\r\n  nodeStart: NodeType, nodeNeighbours: NodeType[],\r\n) => {\r\n  if (condition) {\r\n    const isWallNode = getAttr(nodesH[nodeIdx], dataIsWallNode);\r\n    if (isWallNode === 'false') {\r\n      const node: NodeType = {\r\n        nodeIdx,\r\n        nodeIdxParent: nodeStart.nodeIdx,\r\n      };\r\n      nodeNeighbours.push(node);\r\n    }\r\n  }\r\n};\r\n\r\nconst breadthFirstSearchHelper = (\r\n  animations: number[], queue: NodeType[], targetType: string, nodeTarget: number,\r\n) => {\r\n  let nodeStart: NodeType = { nodeIdx: -1, nodeIdxParent: -1 };\r\n  if (queue.length >= 1) [nodeStart] = queue;\r\n  closedNodes.set(nodeStart.nodeIdx, nodeStart);\r\n  openNodes.delete(nodeStart.nodeIdx);\r\n  queue.shift();\r\n\r\n  if (nodeStart.nodeIdx === nodeTarget) { animations.push(nodeStart.nodeIdx); return; }\r\n  if (nodeStart.nodeIdx === -1 && queue.length === 0 && targetType === '') { isPathFound = false; return; }\r\n  if (nodeStart.nodeIdx === -1 && queue.length === 0 && targetType !== '') { isBombPathFound = false; return; }\r\n\r\n  animations.push(nodeStart.nodeIdx);\r\n  const nodeNeighbours: NodeType[] = [];\r\n\r\n  let nodeIdx = 0;\r\n  // neighbour up\r\n  nodeIdx = nodeStart.nodeIdx - noOfNodesH;\r\n  getNeighbour(\r\n    conditionUp(nodesH[nodeStart.nodeIdx]), nodeIdx, nodeStart, nodeNeighbours,\r\n  );\r\n\r\n  // neighbour down\r\n  nodeIdx = nodeStart.nodeIdx + noOfNodesH;\r\n  getNeighbour(\r\n    conditionDown(nodesH[nodeStart.nodeIdx]), nodeIdx, nodeStart, nodeNeighbours,\r\n  );\r\n\r\n  // neighbour left\r\n  nodeIdx = nodeStart.nodeIdx - 1;\r\n  getNeighbour(\r\n    conditionLeft(nodesH[nodeStart.nodeIdx]), nodeIdx, nodeStart, nodeNeighbours,\r\n  );\r\n\r\n  // neighbour right\r\n  nodeIdx = nodeStart.nodeIdx + 1;\r\n  getNeighbour(\r\n    conditionRight(nodesH[nodeStart.nodeIdx]), nodeIdx, nodeStart, nodeNeighbours,\r\n  );\r\n\r\n  nodeNeighbours.forEach((node: NodeType) => {\r\n    const isNeighbourInClosed = closedNodes.has(node.nodeIdx);\r\n    const isNeighbourInOpen = openNodes.has(node.nodeIdx);\r\n    if (!isNeighbourInClosed && !isNeighbourInOpen) {\r\n      openNodes.set(node.nodeIdx, node);\r\n      queue.push(node);\r\n    }\r\n  });\r\n\r\n  breadthFirstSearchHelper(animations, queue, targetType, nodeTarget);\r\n};\r\n\r\nconst breadthFirstSearch = (\r\n  nodes: HTMLDivElement[],\r\n  noOfRows: number,\r\n  noOfNodes: number,\r\n  hideCover: () => void,\r\n  showError: () => void,\r\n) => {\r\n  nodesH = nodes;\r\n  noOfNodesH = noOfNodes;\r\n  startNode = getNodeStartInfo();\r\n  targetNode = getNodeTargetInfo();\r\n  bombNode = getBombIndex();\r\n  isPathFound = true;\r\n  isBombPathFound = true;\r\n  closedNodes.clear();\r\n  openNodes.clear();\r\n\r\n  const bombIndex = getNodeBombInfo();\r\n  const bombAnimations: number[] = [];\r\n  const targetAnimations: number[] = [];\r\n  const optimalPath: number[] = [];\r\n\r\n  if (bombNode !== -1) {\r\n    const queue: NodeType[] = [];\r\n    queue.push({ nodeIdx: startNode.index, nodeIdxParent: 0 });\r\n    openNodes.set(startNode.index, { nodeIdx: startNode.index, nodeIdxParent: 0 });\r\n    breadthFirstSearchHelper(bombAnimations, queue, 'B', bombIndex.index);\r\n    if (isBombPathFound) {\r\n      const auxPath = [];\r\n      auxPath.push(bombIndex.index);\r\n      findOptimalPath(auxPath, optimalPath, startNode.index, bombIndex.index, closedNodes, true);\r\n    }\r\n\r\n    openNodes.clear();\r\n    closedNodes.clear();\r\n    // T for target\r\n    const queueT: NodeType[] = [];\r\n    queueT.push({ nodeIdx: bombIndex.index, nodeIdxParent: 0 });\r\n    openNodes.set(bombIndex.index, { nodeIdx: bombIndex.index, nodeIdxParent: 0 });\r\n    if (isBombPathFound) {\r\n      breadthFirstSearchHelper(targetAnimations, queueT, '', targetNode.index);\r\n      if (isPathFound) {\r\n        const auxPath = [];\r\n        auxPath.push(targetNode.index);\r\n        findOptimalPath(auxPath, optimalPath, bombIndex.index, targetNode.index, closedNodes, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (bombNode === -1) {\r\n    const queue: NodeType[] = [];\r\n    queue.push({ nodeIdx: startNode.index, nodeIdxParent: 0 });\r\n    openNodes.set(startNode.index, { nodeIdx: startNode.index, nodeIdxParent: 0 });\r\n    breadthFirstSearchHelper(targetAnimations, queue, '', targetNode.index);\r\n    if (isPathFound) {\r\n      const auxPath = [];\r\n      auxPath.push(targetNode.index);\r\n      findOptimalPath(auxPath, optimalPath, startNode.index, targetNode.index, closedNodes, true);\r\n    }\r\n  }\r\n\r\n  animateBombNode(\r\n    nodes, bombAnimations, targetAnimations, optimalPath,\r\n    hideCover, showError, bombNode, isPathFound, isBombPathFound,\r\n  );\r\n};\r\n\r\nexport default breadthFirstSearch;\r\n","// Depth-first search\r\nimport { getBombIndex } from '../App.Functions';\r\nimport { dataIsWallNode } from '../helperFunctions/customAttr';\r\nimport {\r\n  getAttr, getNodeBombInfo, getNodeStartInfo, getNodeTargetInfo,\r\n} from '../helperFunctions/helperFunctions';\r\nimport {\r\n  animateBombNode, conditionDown, conditionLeft, conditionRight, conditionUp, findOptimalPath,\r\n} from './pathfindingAlgorithmsOptions';\r\n\r\ninterface NodeType {\r\n  nodeIdx: number,\r\n  nodeIdxParent: number,\r\n  directionToVisit: string[],\r\n  directionVisited: string[],\r\n}\r\n\r\nconst UP = 'UP';\r\nconst DOWN = 'DOWN';\r\nconst LEFT = 'LEFT';\r\nconst RIGHT = 'RIGHT';\r\n\r\nconst openNodes: Map<number, NodeType> = new Map();\r\nconst closedNodes: Map<number, NodeType> = new Map();\r\nlet startNode = getNodeStartInfo();\r\nlet targetNode = getNodeTargetInfo();\r\nlet bombNode = getBombIndex();\r\nlet isPathFound = true;\r\nlet isBombPathFound = true;\r\n// H for helper\r\nlet nodesH: HTMLDivElement[] = [];\r\nlet noOfNodesH: number = 0;\r\n\r\nconst getNeighbour = (\r\n  condition: boolean, nodeIdx: number,\r\n  nodeStart: NodeType, nodeNeighbours: NodeType[],\r\n) => {\r\n  if (condition) {\r\n    const isWallNode = getAttr(nodesH[nodeIdx], dataIsWallNode);\r\n    if (isWallNode === 'false') {\r\n      const node: NodeType = {\r\n        nodeIdx,\r\n        nodeIdxParent: nodeStart.nodeIdx,\r\n        directionToVisit: [],\r\n        directionVisited: [],\r\n      };\r\n      nodeNeighbours.push(node);\r\n    }\r\n  }\r\n};\r\n\r\nconst depthFirstSearchHelper = (\r\n  animations: number[], stack: NodeType[], targetType: string, nodeTarget: number,\r\n) => {\r\n  let nodeStart: NodeType = {\r\n    nodeIdx: -1, nodeIdxParent: -1, directionToVisit: [], directionVisited: [],\r\n  };\r\n  if (stack.length >= 1) nodeStart = stack[stack.length - 1];\r\n\r\n  if (nodeStart.nodeIdx === nodeTarget) {\r\n    animations.push(nodeStart.nodeIdx);\r\n    closedNodes.set(nodeStart.nodeIdx, nodeStart);\r\n    return;\r\n  }\r\n  if (nodeStart.nodeIdx === -1 && stack.length === 0 && targetType === '') { isPathFound = false; return; }\r\n  if (nodeStart.nodeIdx === -1 && stack.length === 0 && targetType !== '') { isBombPathFound = false; return; }\r\n\r\n  if (nodeStart.directionVisited.length === 0) {\r\n    if (conditionUp(nodesH[nodeStart.nodeIdx])) nodeStart.directionToVisit.push(UP);\r\n    if (conditionDown(nodesH[nodeStart.nodeIdx])) nodeStart.directionToVisit.push(DOWN);\r\n    if (conditionLeft(nodesH[nodeStart.nodeIdx])) nodeStart.directionToVisit.push(LEFT);\r\n    if (conditionRight(nodesH[nodeStart.nodeIdx])) nodeStart.directionToVisit.push(RIGHT);\r\n  }\r\n\r\n  const randomIndex = Math.floor(Math.random() * nodeStart.directionToVisit.length);\r\n  const direction = nodeStart.directionToVisit[randomIndex];\r\n  const indexOfDirection = nodeStart.directionToVisit.indexOf(direction);\r\n  nodeStart.directionVisited.push(direction);\r\n  nodeStart.directionToVisit.splice(indexOfDirection, 1);\r\n\r\n  const isNeighbourInClosedH = closedNodes.has(nodeStart.nodeIdx);\r\n  if (!isNeighbourInClosedH) closedNodes.set(nodeStart.nodeIdx, nodeStart);\r\n  if (nodeStart.directionToVisit.length === 0) {\r\n    // closedNodes.set(nodeStart.nodeIdx, nodeStart);\r\n    openNodes.delete(nodeStart.nodeIdx);\r\n    stack.pop();\r\n  }\r\n\r\n  const nodeIndexAnimation = animations.indexOf(nodeStart.nodeIdx);\r\n  if (nodeIndexAnimation === -1) animations.push(nodeStart.nodeIdx);\r\n  const nodeNeighbours: NodeType[] = [];\r\n\r\n  let nodeIdx = 0;\r\n  // neighbour up\r\n  if (direction === UP) {\r\n    nodeIdx = nodeStart.nodeIdx - noOfNodesH;\r\n    getNeighbour(\r\n      conditionUp(nodesH[nodeStart.nodeIdx]), nodeIdx, nodeStart, nodeNeighbours,\r\n    );\r\n  }\r\n\r\n  // neighbour down\r\n  if (direction === DOWN) {\r\n    nodeIdx = nodeStart.nodeIdx + noOfNodesH;\r\n    getNeighbour(\r\n      conditionDown(nodesH[nodeStart.nodeIdx]), nodeIdx, nodeStart, nodeNeighbours,\r\n    );\r\n  }\r\n\r\n  // neighbour left\r\n  if (direction === LEFT) {\r\n    nodeIdx = nodeStart.nodeIdx - 1;\r\n    getNeighbour(\r\n      conditionLeft(nodesH[nodeStart.nodeIdx]), nodeIdx, nodeStart, nodeNeighbours,\r\n    );\r\n  }\r\n\r\n  // neighbour right\r\n  if (direction === RIGHT) {\r\n    nodeIdx = nodeStart.nodeIdx + 1;\r\n    getNeighbour(\r\n      conditionRight(nodesH[nodeStart.nodeIdx]), nodeIdx, nodeStart, nodeNeighbours,\r\n    );\r\n  }\r\n\r\n  // nodeNeighbours array should have on item\r\n  nodeNeighbours.forEach((node: NodeType) => {\r\n    const isNeighbourInClosed = closedNodes.has(node.nodeIdx);\r\n    const isNeighbourInOpen = openNodes.has(node.nodeIdx);\r\n    if (!isNeighbourInClosed && !isNeighbourInOpen) {\r\n      openNodes.set(node.nodeIdx, node);\r\n      stack.push(node);\r\n    }\r\n  });\r\n\r\n  depthFirstSearchHelper(animations, stack, targetType, nodeTarget);\r\n};\r\n\r\nconst depthFirstSearch = (\r\n  nodes: HTMLDivElement[],\r\n  noOfRows: number,\r\n  noOfNodes: number,\r\n  hideCover: () => void,\r\n  showError: () => void,\r\n) => {\r\n  nodesH = nodes;\r\n  noOfNodesH = noOfNodes;\r\n  startNode = getNodeStartInfo();\r\n  targetNode = getNodeTargetInfo();\r\n  bombNode = getBombIndex();\r\n  isPathFound = true;\r\n  isBombPathFound = true;\r\n  closedNodes.clear();\r\n  openNodes.clear();\r\n\r\n  const bombIndex = getNodeBombInfo();\r\n  const bombAnimations: number[] = [];\r\n  const targetAnimations: number[] = [];\r\n  const optimalPath: number[] = [];\r\n\r\n  if (bombNode !== -1) {\r\n    const stack: NodeType[] = [];\r\n    stack.push({\r\n      nodeIdx: startNode.index, nodeIdxParent: 0, directionToVisit: [], directionVisited: [],\r\n    });\r\n    openNodes.set(startNode.index, {\r\n      nodeIdx: startNode.index, nodeIdxParent: 0, directionToVisit: [], directionVisited: [],\r\n    });\r\n    depthFirstSearchHelper(bombAnimations, stack, 'B', bombIndex.index);\r\n    if (isBombPathFound) {\r\n      const auxPath = [];\r\n      auxPath.push(bombIndex.index);\r\n      findOptimalPath(auxPath, optimalPath, startNode.index, bombIndex.index, closedNodes, true);\r\n    }\r\n\r\n    openNodes.clear();\r\n    closedNodes.clear();\r\n    // T for target\r\n    const stackT: NodeType[] = [];\r\n    stackT.push({\r\n      nodeIdx: bombIndex.index, nodeIdxParent: 0, directionToVisit: [], directionVisited: [],\r\n    });\r\n    openNodes.set(bombIndex.index, {\r\n      nodeIdx: bombIndex.index, nodeIdxParent: 0, directionToVisit: [], directionVisited: [],\r\n    });\r\n    if (isBombPathFound) {\r\n      depthFirstSearchHelper(targetAnimations, stackT, '', targetNode.index);\r\n      if (isPathFound) {\r\n        const auxPath = [];\r\n        auxPath.push(targetNode.index);\r\n        findOptimalPath(auxPath, optimalPath, bombIndex.index, targetNode.index, closedNodes, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (bombNode === -1) {\r\n    const stack: NodeType[] = [];\r\n    stack.push({\r\n      nodeIdx: startNode.index, nodeIdxParent: 0, directionToVisit: [], directionVisited: [],\r\n    });\r\n    openNodes.set(startNode.index, {\r\n      nodeIdx: startNode.index, nodeIdxParent: 0, directionToVisit: [], directionVisited: [],\r\n    });\r\n    depthFirstSearchHelper(targetAnimations, stack, '', targetNode.index);\r\n    if (isPathFound) {\r\n      const auxPath = [];\r\n      auxPath.push(targetNode.index);\r\n      findOptimalPath(auxPath, optimalPath, startNode.index, targetNode.index, closedNodes, true);\r\n    }\r\n  }\r\n\r\n  animateBombNode(\r\n    nodes, bombAnimations, targetAnimations, optimalPath,\r\n    hideCover, showError, bombNode, isPathFound, isBombPathFound,\r\n  );\r\n};\r\n\r\nexport default depthFirstSearch;\r\n","import React, { ForwardedRef } from 'react';\r\nimport { Menu } from 'semantic-ui-react';\r\nimport { Alert } from 'react-bootstrap';\r\nimport pathfindingAlgorithmsOptions, { algorithms } from '../pathfindingAlgorihms/pathfindingAlgorithmsOptions';\r\nimport Nav from './Nav';\r\nimport { arrowDown, topNav, TopNavProps } from '../helperFunctions/props';\r\nimport './Nav.css';\r\nimport aStar from '../pathfindingAlgorihms/aStar';\r\nimport {\r\n  addBomb, clearPathNodes, getBombIndex, setTtypeOfSearchAlgorithm,\r\n} from '../App.Functions';\r\nimport bidirectionalSearch from '../pathfindingAlgorihms/bidirectionalSearch';\r\nimport dijkstras from '../pathfindingAlgorihms/dijkstras';\r\nimport breadthFirstSearch from '../pathfindingAlgorihms/breadthFirstSearch';\r\nimport depthFirstSearch from '../pathfindingAlgorihms/depthFirstSearch';\r\n\r\nconst TopNav = React.forwardRef((props: TopNavProps, ref: ForwardedRef<HTMLDivElement>) => {\r\n  const [showAlert, setShowAlert] = React.useState(false);\r\n  const [showNoPath, setShowNoPath] = React.useState(false);\r\n\r\n  const options = [];\r\n  const pathFindingAlgorithmsOptions = pathfindingAlgorithmsOptions();\r\n  for (let i = 0; i < pathFindingAlgorithmsOptions.length; i += 1) {\r\n    const pathFindingOptionVal = pathFindingAlgorithmsOptions[i];\r\n    options.push(\r\n      <option key={pathFindingOptionVal.key} value={pathFindingOptionVal.value}>\r\n        {pathFindingOptionVal.text}\r\n      </option>,\r\n    );\r\n  }\r\n\r\n  let noPathTimer = 0;\r\n  // F for function\r\n  const showNoPathF = () => {\r\n    setShowNoPath(true);\r\n    if (noPathTimer) clearTimeout(noPathTimer);\r\n    noPathTimer = window.setTimeout(() => {\r\n      setShowNoPath(false);\r\n    }, 4000);\r\n  };\r\n\r\n  let timer = 0;\r\n  const visualize = (e: any) => {\r\n    e.preventDefault();\r\n    clearPathNodes(props.nodes.current!!);\r\n    const dropdown = (ref as React.RefObject<HTMLDivElement>).current?.childNodes[1].childNodes[0];\r\n    const { value } = (dropdown as HTMLSelectElement);\r\n    switch (value) {\r\n      case algorithms[0]:\r\n        props.showCover();\r\n        aStar(props.nodes.current!!, props.noOfRows, props.noOfNodes, props.hideCover, showNoPathF);\r\n        break;\r\n      case algorithms[1]:\r\n        props.showCover();\r\n        bidirectionalSearch(\r\n          props.nodes.current!!, props.noOfRows, props.noOfNodes, props.hideCover, showNoPathF,\r\n        );\r\n        break;\r\n      case algorithms[2]:\r\n        props.showCover();\r\n        breadthFirstSearch(\r\n          props.nodes.current!!, props.noOfRows, props.noOfNodes, props.hideCover, showNoPathF,\r\n        );\r\n        break;\r\n      case algorithms[3]:\r\n        props.showCover();\r\n        depthFirstSearch(\r\n          props.nodes.current!!, props.noOfRows, props.noOfNodes, props.hideCover, showNoPathF,\r\n        );\r\n        break;\r\n      case algorithms[4]:\r\n        props.showCover();\r\n        dijkstras(\r\n          props.nodes.current!!, props.noOfRows, props.noOfNodes, props.hideCover, showNoPathF,\r\n        );\r\n        break;\r\n      default:\r\n        setShowAlert(true);\r\n        if (timer) clearTimeout(timer);\r\n        timer = window.setTimeout(() => {\r\n          setShowAlert(false);\r\n        }, 2000);\r\n    }\r\n  };\r\n\r\n  // select on change\r\n  const selectOnChange = () => {\r\n    const dropdown = (ref as React.RefObject<HTMLDivElement>).current?.childNodes[1].childNodes[0];\r\n    const { value } = (dropdown as HTMLSelectElement);\r\n    const sideNavAddBomb = props.sideNav?.current?.children[1];\r\n    // Remove bomb node\r\n    if (value === algorithms[1]) {\r\n      sideNavAddBomb!!.classList.add('disabled');\r\n    } else {\r\n      sideNavAddBomb!!.classList.remove('disabled');\r\n    }\r\n\r\n    if (value === algorithms[1] && getBombIndex() !== -1) {\r\n      addBomb(props.noOfNodes, props.nodes.current!!, props.sideNav.current);\r\n      // sideNavAddBomb!!.classList.add('disabled');\r\n    } else {\r\n      // sideNavAddBomb!!.classList.remove('disabled');\r\n    }\r\n    setTtypeOfSearchAlgorithm(value);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div ref={ref} className=\"ui menu ui-menu\">\r\n        <span className=\"show-for-large\">\r\n          <Nav\r\n            navType={topNav}\r\n            arrowDirection={arrowDown}\r\n            animateMazesAndPatterns={props.animateMazesAndPatterns}\r\n            mazesPatternButtonsRef={props.mazesPatternButtonsRef}\r\n            currentActiveMazeAndPattern={props.currentActiveMazeAndPattern}\r\n          />\r\n        </span>\r\n        <Menu.Item>\r\n          <select\r\n            style={{ padding: '5px 5px' }}\r\n            name=\"sorting_algorithms\"\r\n            className=\"ui selection fluid dropdown\"\r\n            defaultValue=\"\"\r\n            onChange={selectOnChange}\r\n          >\r\n            <option value=\"\" disabled>Select Pathfinding Algo .....</option>\r\n            {options}\r\n          </select>\r\n        </Menu.Item>\r\n\r\n        <Menu.Item>\r\n          <a\r\n            href=\"/visualize\"\r\n            className=\"ui fluid blue submit button\"\r\n            onClick={(e) => { visualize(e); }}\r\n          >\r\n            Go\r\n          </a>\r\n        </Menu.Item>\r\n      </div>\r\n      <Alert\r\n        style={{\r\n          position: 'fixed',\r\n          width: '315px',\r\n          right: 0,\r\n          left: 0,\r\n          margin: 'auto',\r\n          zIndex: 9999,\r\n        }}\r\n        variant=\"danger\"\r\n        show={showAlert}\r\n        dismissible\r\n        onClose={() => { setShowAlert(false); }}\r\n        transition={false}\r\n      >\r\n        Select a Pathfinding Algorihm.\r\n      </Alert>\r\n\r\n      <Alert\r\n        style={{\r\n          position: 'fixed',\r\n          width: '315px',\r\n          right: 0,\r\n          left: 0,\r\n          margin: 'auto',\r\n          zIndex: 9999,\r\n        }}\r\n        variant=\"danger\"\r\n        show={showNoPath}\r\n        dismissible\r\n        onClose={() => { setShowNoPath(false); }}\r\n        transition={false}\r\n      >\r\n        No Path Found.\r\n      </Alert>\r\n    </>\r\n  );\r\n});\r\n\r\nexport default TopNav;\r\n","import React, { ForwardedRef } from 'react';\r\nimport { arrowUp, NavProps, bottomNav } from '../helperFunctions/props';\r\nimport Nav from './Nav';\r\n\r\nconst BottomNav = React.forwardRef((props: NavProps, ref: ForwardedRef<HTMLDivElement>) => (\r\n  <div ref={ref} className=\"ui bottom fixed two item menu show-for-medium\">\r\n    <Nav\r\n      navType={bottomNav}\r\n      arrowDirection={arrowUp}\r\n      animateMazesAndPatterns={props.animateMazesAndPatterns}\r\n      mazesPatternButtonsRef={props.mazesPatternButtonsRef}\r\n      currentActiveMazeAndPattern={props.currentActiveMazeAndPattern}\r\n    />\r\n  </div>\r\n));\r\n\r\nexport default BottomNav;\r\n","import React, { ForwardedRef, RefObject, useState } from 'react';\r\nimport { Menu, Icon } from 'semantic-ui-react';\r\nimport {\r\n  shortestPathNodeColor, transparent, visitedNodeColor, visitedNodeColorToBomb, wallNodeColor,\r\n} from '../helperFunctions/color';\r\nimport { getDarkMode } from '../helperFunctions/helperFunctions';\r\nimport { SideNavDivProps } from '../helperFunctions/props';\r\nimport { setTimer } from '../pathfindingAlgorihms/pathfindingAlgorithmsOptions';\r\nimport './SideNav.css';\r\n\r\nconst FAST = 'Fast';\r\nconst AVERAGE = 'Average';\r\nconst SLOW = 'Slow';\r\n\r\nconst speedOnClick = (\r\n  // eslint-disable-next-line no-unused-vars\r\n  type: String, setActive: (active: number) => void, sideNavRef: RefObject<HTMLDivElement> | null,\r\n  // eslint-disable-next-line no-unused-vars\r\n  setDisplay: (display: string) => void,\r\n) => {\r\n  const speedMenu = sideNavRef?.current?.children[0];\r\n  const speedText = speedMenu?.children[1].children[0];\r\n  if (type === FAST) {\r\n    speedText!!.textContent = ` ${FAST}`;\r\n    setTimer(20);\r\n    setActive(0);\r\n  }\r\n\r\n  if (type === AVERAGE) {\r\n    speedText!!.textContent = ` ${AVERAGE}`;\r\n    setTimer(100);\r\n    setActive(1);\r\n  }\r\n\r\n  if (type === SLOW) {\r\n    speedText!!.textContent = ` ${SLOW}`;\r\n    setTimer(500);\r\n    setActive(2);\r\n  }\r\n\r\n  setDisplay('none');\r\n};\r\n\r\nconst animateSideNavRefWidth = (\r\n  // eslint-disable-next-line no-unused-vars\r\n  sideNavRef: RefObject<HTMLDivElement> | null, setLeft: (left: number) => void,\r\n) => {\r\n  // H for helper\r\n  const sideNavRefH = sideNavRef!!.current!!;\r\n  const sideNavRefHWidth = sideNavRefH.style.width;\r\n  // eslint-disable-next-line no-unused-expressions\r\n  // sideNavRefHWidth === '50px' ? sideNavRefH.style.width = '200px'\r\n  //   : sideNavRefH.style.width = '50px';\r\n  if (sideNavRefHWidth === '50px') {\r\n    sideNavRefH.classList.remove('side-nav');\r\n    sideNavRefH.classList.add('side-nav-open');\r\n    sideNavRefH.style.width = '200px';\r\n    setLeft(205);\r\n  } else {\r\n    sideNavRefH.classList.remove('side-nav-open');\r\n    sideNavRefH.classList.add('side-nav');\r\n    sideNavRefH.style.width = '50px';\r\n    setLeft(55);\r\n  }\r\n};\r\n\r\nconst infoOnClick = (sideNavRef: RefObject<HTMLDivElement>) => {\r\n  // H for helper\r\n  const sideNavRefH = sideNavRef.current!!;\r\n  const sideNavRefHWidth = sideNavRefH.style.width;\r\n\r\n  if (sideNavRefHWidth === '50px') {\r\n    sideNavRefH.classList.remove('side-nav');\r\n    sideNavRefH.classList.add('side-nav-open');\r\n    sideNavRefH.style.width = '200px';\r\n  }\r\n};\r\n\r\n// export const OpenSideNav = React.forwardRef((\r\n//   props: OpenSideNavProps, ref: ForwardedRef<HTMLDivElement>,\r\n// ) => (\r\n//   <div\r\n//     style={{\r\n//       width: '50px',\r\n//       height: '50px',\r\n//       position: 'absolute',\r\n//       top: `${props.top}px`,\r\n//     }}\r\n//     className=\"ui vertical menu open-side-nav\"\r\n//     ref={ref}\r\n//   >\r\n//     <Menu.Item\r\n//       className=\"open-menu-item\"\r\n//       onClick={() => { animateSideNavRefWidth(props.sideNavRef); }}\r\n//     >\r\n//       <Icon name=\"grid layout\" />\r\n//     </Menu.Item>\r\n//   </div>\r\n// ));\r\n\r\nconst SideNav = React.forwardRef((\r\n  props: SideNavDivProps, ref: ForwardedRef<HTMLDivElement>,\r\n) => {\r\n  const [left, setLeft] = useState(55);\r\n  const [display, setDisplay] = useState('none');\r\n  const [active, setActive] = useState(1);\r\n  const setLeftHelper = (leftHelper: number) => { setLeft(leftHelper); };\r\n  // const setActiveHelper = (activeHelper: number) => { setActive(activeHelper); };\r\n  const className = getDarkMode()\r\n    ? 'ui vertical menu speed-menu speed-menu-inverted inverted'\r\n    : 'ui vertical menu speed-menu';\r\n  return (\r\n    <>\r\n      {/* open side nav */}\r\n      <div\r\n        style={{\r\n          width: '50px',\r\n          height: '50px',\r\n          position: 'absolute',\r\n          top: `${props.top}px`,\r\n        }}\r\n        className=\"ui vertical menu open-side-nav\"\r\n        ref={props.openSideNavRef}\r\n      >\r\n        <Menu.Item\r\n          className=\"open-menu-item\"\r\n          onClick={() => {\r\n            animateSideNavRefWidth(ref as RefObject<HTMLDivElement>, setLeftHelper);\r\n          }}\r\n        >\r\n          <Icon name=\"grid layout\" />\r\n        </Menu.Item>\r\n      </div>\r\n\r\n      {/* speed menu */}\r\n      <div\r\n        ref={props.speedSideNavRef}\r\n        style={{\r\n          left: `${left}px`,\r\n          top: `${props.top + 55}px`,\r\n          display,\r\n        }}\r\n        className={className}\r\n      >\r\n        <Menu.Item\r\n          className={active === 0 ? 'active' : ''}\r\n          onClick={\r\n            () => speedOnClick(FAST, setActive, ref as RefObject<HTMLDivElement>, setDisplay)\r\n          }\r\n        >\r\n          {FAST}\r\n        </Menu.Item>\r\n        <Menu.Item\r\n          className={active === 1 ? 'active' : ''}\r\n          onClick={\r\n            () => speedOnClick(AVERAGE, setActive, ref as RefObject<HTMLDivElement>, setDisplay)\r\n          }\r\n        >\r\n          {AVERAGE}\r\n        </Menu.Item>\r\n        <Menu.Item\r\n          className={active === 2 ? 'active' : ''}\r\n          onClick={\r\n            () => speedOnClick(SLOW, setActive, ref as RefObject<HTMLDivElement>, setDisplay)\r\n          }\r\n        >\r\n          {SLOW}\r\n        </Menu.Item>\r\n      </div>\r\n\r\n      <div\r\n        style={{\r\n          width: '50px',\r\n          position: 'absolute',\r\n          height: `${props.height - 55}px`,\r\n          top: `${props.top + 55}px`,\r\n        }}\r\n        className=\"ui vertical menu side-nav\"\r\n        ref={ref}\r\n      >\r\n        <Menu.Item\r\n          className=\"menu-item\"\r\n          onClick={() => {\r\n            if (display === 'none') {\r\n              setDisplay('block');\r\n            } else {\r\n              setDisplay('none');\r\n            }\r\n          }}\r\n        >\r\n          <Icon name=\"lightning\" />\r\n          <span className=\"menu-item-name\">\r\n            Speed:\r\n            <span style={{ fontWeight: 'bold' }}> Average</span>\r\n          </span>\r\n        </Menu.Item>\r\n\r\n        <Menu.Item className=\"menu-item\" onClick={props.addBomb}>\r\n          <Icon name=\"bomb\" />\r\n          <span className=\"menu-item-name\">Add Bomb</span>\r\n        </Menu.Item>\r\n\r\n        <Menu.Item className=\"menu-item\" onClick={props.resetBoard}>\r\n          <Icon name=\"refresh\" />\r\n          <span className=\"menu-item-name\">Reset Board</span>\r\n        </Menu.Item>\r\n\r\n        <Menu.Item className=\"menu-item\" onClick={props.clearPathNodes}>\r\n          <Icon name=\"close\" />\r\n          <span className=\"menu-item-name\">Clear Path</span>\r\n        </Menu.Item>\r\n\r\n        <Menu.Item className=\"menu-item\" onClick={props.clearWalls}>\r\n          <Icon name=\"window close\" />\r\n          <span className=\"menu-item-name\">Clear Walls</span>\r\n        </Menu.Item>\r\n\r\n        <Menu.Item className=\"menu-item\" onClick={() => { infoOnClick(ref as RefObject<HTMLDivElement>); }}>\r\n          <Icon name=\"info\" />\r\n          <span className=\"menu-item-name\">Info</span>\r\n\r\n          <div style={{ marginTop: '5px' }} className=\"info-div\">\r\n            <span>\r\n              <Icon name=\"chevron right\" />\r\n              Start Node\r\n            </span>\r\n\r\n            <br />\r\n            <span>\r\n              <Icon name=\"bullseye\" />\r\n              Target Node\r\n            </span>\r\n\r\n            <br />\r\n            <span>\r\n              <Icon name=\"bomb\" />\r\n              Bomb Node\r\n            </span>\r\n\r\n            <br />\r\n            <span>\r\n              <div className=\"info-span-div\" style={{ backgroundColor: transparent }} />\r\n              <span>Unvisited Node</span>\r\n            </span>\r\n\r\n            <br />\r\n            <span>\r\n              <div className=\"info-span-div\" style={{ backgroundColor: shortestPathNodeColor }} />\r\n              <span>Shortest-path Node</span>\r\n            </span>\r\n\r\n            <br />\r\n            <span>\r\n              <div className=\"info-span-div\" style={{ backgroundColor: wallNodeColor }} />\r\n              <span>Wall Node</span>\r\n            </span>\r\n\r\n            <br />\r\n            <span>\r\n              <div className=\"info-span-div\" style={{ backgroundColor: visitedNodeColor }} />\r\n              <div className=\"info-span-div\" style={{ marginLeft: 5, backgroundColor: visitedNodeColorToBomb }} />\r\n              <span>Visited Nodes</span>\r\n            </span>\r\n          </div>\r\n        </Menu.Item>\r\n      </div>\r\n    </>\r\n  );\r\n});\r\n\r\nexport default SideNav;\r\n","import React, { ForwardedRef } from 'react';\r\nimport BootstrapSwitchButton from 'bootstrap-switch-button-react';\r\nimport { Label } from 'semantic-ui-react';\r\nimport './MazesPatternSwitchButton.css';\r\n\r\ninterface Props {\r\n  isSliderChecked: boolean;\r\n  // eslint-disable-next-line no-unused-vars\r\n  darkModeToggle: (checked: boolean) => void;\r\n}\r\n\r\nconst MazesPatternSwitchButton = React.forwardRef((\r\n  props: Props, ref: ForwardedRef<HTMLDivElement>,\r\n) => {\r\n  const { isSliderChecked, darkModeToggle } = props;\r\n  const darkMode = <i className=\"moon icon\" />;\r\n  const lightMode = <i className=\"sun outline icon\" />;\r\n  return (\r\n    <div className=\"mazes-pattern-label\">\r\n      <div style={{ marginRight: '5px' }}>\r\n        <BootstrapSwitchButton\r\n          checked={isSliderChecked}\r\n          width={50}\r\n          onlabel={lightMode as unknown as string}\r\n          onstyle=\"dark\"\r\n          offlabel={darkMode as unknown as string}\r\n          offstyle=\"primary\"\r\n          // eslint-disable-next-line react/style-prop-object\r\n          style=\"border\"\r\n          onChange={(checked: boolean) => { darkModeToggle(checked); }}\r\n        />\r\n      </div>\r\n\r\n      <Label color=\"blue\" style={{ marginLeft: '5px' }}>\r\n        Current Maze & Pattern\r\n        <br />\r\n        <div ref={ref} className=\"detail\">None</div>\r\n      </Label>\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default MazesPatternSwitchButton;\r\n","/* eslint-disable jsx-a11y/no-static-element-interactions */\r\n/* eslint-disable jsx-a11y/click-events-have-key-events */\r\nimport React, { ForwardedRef, RefObject } from 'react';\r\nimport {\r\n  startNode, targetNode, createDraggble, getDarkMode,\r\n} from '../helperFunctions/helperFunctions';\r\nimport { RowsType, RowType, NodeType } from '../helperFunctions/types';\r\nimport './PathFindingGrid.css';\r\n\r\ninterface Props {\r\n  pfGridHeight: number;\r\n  marginTop: number;\r\n  pfGridRows: RowsType;\r\n  nodesRef: RefObject<Array<HTMLDivElement>>;\r\n  noOfNodes: number;\r\n  // eslint-disable-next-line no-unused-vars\r\n  onMouseDown: (elem: HTMLElement) => void;\r\n  // eslint-disable-next-line no-unused-vars\r\n  onMouseEnter: (elem: HTMLElement,) => void;\r\n}\r\n\r\nconst PathFindingGrid = React.forwardRef((props: Props, ref: ForwardedRef<HTMLDivElement>) => {\r\n  const {\r\n    pfGridHeight,\r\n    marginTop,\r\n    pfGridRows,\r\n    nodesRef,\r\n    noOfNodes,\r\n    onMouseDown,\r\n    onMouseEnter,\r\n  } = props;\r\n\r\n  let iNode: HTMLElement[] = [];\r\n  const createStartTargetNode = (node: HTMLDivElement, nodeIndex: number, type: string) => {\r\n    if (iNode.length > nodeIndex) {\r\n      iNode.forEach((elem: HTMLElement) => {\r\n        elem.remove();\r\n      });\r\n      iNode = [];\r\n    }\r\n    iNode[nodeIndex] = document.createElement('i');\r\n    const addDarkMode = getDarkMode() ? 'inverted' : 'NA';\r\n    if (type === startNode) {\r\n      iNode[nodeIndex].classList.add('large', 'chevron', 'right', 'icon', addDarkMode, type);\r\n      node?.appendChild(iNode[nodeIndex]);\r\n    }\r\n\r\n    if (type === targetNode) {\r\n      iNode[nodeIndex].classList.add('large', 'bullseye', 'icon', addDarkMode, type);\r\n      node?.appendChild(iNode[nodeIndex]);\r\n    }\r\n    createDraggble(type, nodeIndex, noOfNodes, nodesRef.current);\r\n  };\r\n\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      className=\"pf-grid\"\r\n      style={{\r\n        border: '1px solid #007bff',\r\n        height: `${pfGridHeight}px`,\r\n        marginLeft: '60px',\r\n      }}\r\n    >\r\n      <div className=\"pf-grid-node-holder\" style={{ marginTop: Math.floor(marginTop / 2) }}>\r\n        {\r\n          pfGridRows.length === 0 ? ''\r\n            : pfGridRows.map((row: RowType, idxC: number) => (\r\n              // eslint-disable-next-line react/no-array-index-key\r\n              <div className=\"pf-grid-nodes-row\" key={idxC}>\r\n                {\r\n                  row.map((node: NodeType, idxR: number) => {\r\n                    const {\r\n                      isNodeInFirstCol, isNodeInLastCol, isNodeInFirstRow, isNodeInLastRow,\r\n                      isStartNode, isTargetNode, isWallNode, isBombNode, idx,\r\n                    } = node;\r\n                    const firstColNode = isNodeInFirstCol ? 'first-col-node' : '';\r\n                    const lastRowNode = isNodeInLastRow ? 'last-row-node' : '';\r\n                    const wallNode = isWallNode ? 'wall-node' : '';\r\n\r\n                    return (\r\n                      <div\r\n                        className={\r\n                          `pf-grid-node pf-grid-node-border-color ${firstColNode} ${lastRowNode} ${wallNode}`\r\n                        }\r\n                        // eslint-disable-next-line react/no-array-index-key\r\n                        key={idxR}\r\n                        ref={(element: HTMLDivElement) => {\r\n                          if (isStartNode) createStartTargetNode(element, idx, startNode);\r\n                          if (isTargetNode) createStartTargetNode(element, idx, targetNode);\r\n                          nodesRef.current!![idx] = element;\r\n                        }}\r\n                        data-is-start-node={isStartNode}\r\n                        data-is-target-node={isTargetNode}\r\n                        data-is-wall-node={isWallNode}\r\n                        data-is-bomb-node={isBombNode}\r\n                        data-idx={idx}\r\n                        data-is-first-col={isNodeInFirstCol}\r\n                        data-is-last-col={isNodeInLastCol}\r\n                        data-is-first-row={isNodeInFirstRow}\r\n                        data-is-last-row={isNodeInLastRow}\r\n                        // gap node for mazes\r\n                        data-is-gap-node={false}\r\n                        onMouseDown={(e) => {\r\n                          e.preventDefault();\r\n                          onMouseDown(nodesRef.current!![idx]);\r\n                        }}\r\n                        onMouseEnter={(e) => {\r\n                          e.preventDefault();\r\n                          onMouseEnter(nodesRef.current!![idx]);\r\n                        }}\r\n                      />\r\n                    );\r\n                  })\r\n                }\r\n              </div>\r\n            ))\r\n        }\r\n      </div>\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default PathFindingGrid;\r\n","import { addRemoveWallNode } from '../helperFunctions/helperFunctions';\r\nimport { randomIntFromInterval, resetTimeouts, pushTimer } from './mazesAndPatternsHelper';\r\n\r\nconst basicRandomMaze = (\r\n  nodes: HTMLDivElement[], noOfRows: number, noOfNodes: number, hideCover: () => void,\r\n) => {\r\n  const totalNodes = (noOfRows * noOfNodes);\r\n  const size = Math.floor(totalNodes / 2);\r\n  const aniamtions = [];\r\n\r\n  resetTimeouts([]);\r\n  // //\r\n  for (let i = 0; i < size; i += 1) {\r\n    const nodeIdx = randomIntFromInterval(0, totalNodes - 1);\r\n    aniamtions.push(nodeIdx);\r\n    const timer = window.setTimeout(() => {\r\n      addRemoveWallNode(nodes[nodeIdx], nodeIdx);\r\n      if (i === size - 1) hideCover();\r\n    }, i * 10);\r\n\r\n    pushTimer(timer);\r\n  }\r\n};\r\n\r\nexport default basicRandomMaze;\r\n","import { addRemoveWallNode } from '../helperFunctions/helperFunctions';\r\nimport { resetTimeouts, pushTimer } from './mazesAndPatternsHelper';\r\n\r\n// side of wall being drawn\r\nexport const wallSideUp = 'up';\r\nexport const wallSideDown = 'down';\r\nexport const wallSideRightLeft = 'left';\r\n\r\nexport const drawSideWalls = (\r\n  nodes: HTMLDivElement[], noOfRows: number, noOfNodes: number,\r\n  wallSide: string, animations: (number | number[])[],\r\n) => {\r\n  let init = 0;\r\n  let condition = 0;\r\n  let final = 0;\r\n\r\n  switch (wallSide) {\r\n    case wallSideUp:\r\n      init = 0;\r\n      condition = noOfNodes;\r\n      final = 1;\r\n      break;\r\n    case wallSideDown:\r\n      init = (noOfRows - 1) * noOfNodes;\r\n      condition = noOfRows * noOfNodes;\r\n      final = 1;\r\n      break;\r\n    default:\r\n      init = noOfNodes;\r\n      condition = noOfNodes * (noOfRows - 1);\r\n      final = noOfNodes;\r\n  }\r\n\r\n  for (let i = init; i < condition; i += final) {\r\n    if (wallSide === wallSideRightLeft) {\r\n      animations.push([i, i + noOfNodes - 1]);\r\n    } else {\r\n      animations.push(i);\r\n    }\r\n  }\r\n\r\n  return animations;\r\n};\r\n\r\nexport const animateDrawWalls = (\r\n  animations: (number | number[])[], nodes: HTMLDivElement[], noOfNodes: number,\r\n  recursiveDivisionAnimations: number[], hideCover: () => void,\r\n  animateRecursiveDivision: (\r\n    // H for helper\r\n    // eslint-disable-next-line no-unused-vars\r\n    nodesH: HTMLDivElement[], animationsH: number[], hideCoverH: () => void,\r\n  ) => void,\r\n) => {\r\n  resetTimeouts([]);\r\n\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    const timer = window.setTimeout(() => {\r\n      const idx = animations[i];\r\n      if (i >= noOfNodes && i < animations.length - noOfNodes) {\r\n        const leftIdx = (idx as number[])[0];\r\n        const rightIdx = (idx as number[])[1];\r\n        addRemoveWallNode(nodes[leftIdx], leftIdx);\r\n        addRemoveWallNode(nodes[rightIdx], rightIdx);\r\n      } else {\r\n        addRemoveWallNode(nodes[idx as number], idx as number);\r\n      }\r\n\r\n      if (i === animations.length - 1) {\r\n        animateRecursiveDivision(nodes, recursiveDivisionAnimations, hideCover);\r\n      }\r\n    }, i * 20);\r\n\r\n    pushTimer(timer);\r\n  }\r\n};\r\n","/* eslint-disable no-unused-vars */\r\nimport {\r\n  dataIsStartNode, dataIsTargetNode, dataIsBombNode, dataIsGapNode,\r\n} from '../helperFunctions/customAttr';\r\nimport { getAttr, addRemoveWallNode, addGapNode } from '../helperFunctions/helperFunctions';\r\nimport {\r\n  wallSideUp, wallSideDown, wallSideRightLeft, drawSideWalls, animateDrawWalls,\r\n} from './animateDrawSideWalls';\r\nimport {\r\n  chooseOrientation, horizontal, pushTimer, randomIndex, resetTimeouts,\r\n} from './mazesAndPatternsHelper';\r\n\r\n// H for helper\r\nlet nodesH: HTMLDivElement[] = [];\r\nlet noOfNodesH: number = 0;\r\nlet initialGap = 2;\r\n\r\ninterface offSetType {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n// divide\r\nconst divide = (\r\n  startPos: number, length: number,\r\n  orientation: string, animations: number[], offset: offSetType,\r\n) => {\r\n  const tempAnimations: number[] = [];\r\n  let isGapIndex = false;\r\n  let gapIndex = 0;\r\n  const { x, y } = offset;\r\n  for (let i = 1; i < length + 1; i += 1) {\r\n    const nodeIdx = orientation === horizontal ? ((startPos + y) * noOfNodesH) + i + x\r\n      : ((i + y) * noOfNodesH) + startPos + x;\r\n    const isStartNode = getAttr(nodesH[nodeIdx], dataIsStartNode);\r\n    const isTargetNode = getAttr(nodesH[nodeIdx], dataIsTargetNode);\r\n    const isBombNode = getAttr(nodesH[nodeIdx], dataIsBombNode);\r\n    animations.push(nodeIdx);\r\n    if (isStartNode === 'false' && isTargetNode === 'false' && isBombNode === 'false') {\r\n      tempAnimations.push(nodeIdx);\r\n    }\r\n\r\n    if (i === 1) {\r\n      const nodeIndex = orientation === horizontal ? nodeIdx - 1 : nodeIdx - noOfNodesH;\r\n      const isGapNode = typeof nodesH[nodeIndex] === 'undefined' ? false\r\n        : getAttr(nodesH[nodeIndex], dataIsGapNode);\r\n      if (isGapNode === 'true') {\r\n        isGapIndex = true;\r\n        gapIndex = nodeIndex;\r\n      }\r\n      if (gapIndex !== 0) {\r\n        const animationsNodeIndex = animations.indexOf(nodeIdx);\r\n        if (animationsNodeIndex !== -1) animations.splice(animationsNodeIndex, 1);\r\n        addGapNode(nodesH[nodeIdx], nodeIdx);\r\n        gapIndex = 0;\r\n      }\r\n    }\r\n\r\n    if (i === length) {\r\n      const nodeIndex = orientation === horizontal ? nodeIdx + 1 : nodeIdx + noOfNodesH;\r\n      const isGapNode = typeof nodesH[nodeIndex] === 'undefined' ? false\r\n        : getAttr(nodesH[nodeIndex], dataIsGapNode);\r\n      if (isGapNode === 'true') {\r\n        isGapIndex = true;\r\n        gapIndex = nodeIndex;\r\n      }\r\n      if (gapIndex !== 0) {\r\n        const animationsNodeIndex = animations.indexOf(nodeIdx);\r\n        if (animationsNodeIndex !== -1) animations.splice(animationsNodeIndex, 1);\r\n        addGapNode(nodesH[nodeIdx], nodeIdx);\r\n        gapIndex = 0;\r\n      }\r\n    }\r\n\r\n    if (i === length && !isGapIndex) {\r\n      const randomIdx = randomIndex(tempAnimations.length);\r\n      const nodeIndex = tempAnimations[randomIdx];\r\n      tempAnimations.splice(randomIdx, 1);\r\n      const animationsNodeIndex = animations.indexOf(nodeIndex);\r\n      if (animationsNodeIndex !== -1) animations.splice(animationsNodeIndex, 1);\r\n      addGapNode(nodesH[nodeIndex], nodeIndex);\r\n    }\r\n  }\r\n  initialGap = 0;\r\n};\r\n\r\nconst getStartXY = (length: number, type: string) => {\r\n  const startXOptions = [];\r\n  const startYOptions = [];\r\n  for (let i = 2; i < length; i += 1) {\r\n    if (type === 'X') {\r\n      startXOptions.push(i);\r\n    }\r\n    if (type === 'Y') {\r\n      startYOptions.push(i);\r\n    }\r\n  }\r\n\r\n  if (type === 'X' && startXOptions.length !== 0) {\r\n    const startXIdx = randomIndex(startXOptions.length);\r\n    return startXOptions[startXIdx];\r\n  }\r\n  const startYIdx = randomIndex(startYOptions.length);\r\n  return startYOptions[startYIdx];\r\n};\r\n\r\nconst recursiveDivisionHelper = (\r\n  height: number, width: number,\r\n  orientation: string, animations: number[], offset: offSetType,\r\n) => {\r\n  const startX = getStartXY(height, 'X');\r\n  const startY = getStartXY(width, 'Y');\r\n  const startPos = orientation === horizontal ? startX : startY;\r\n  const length = orientation === horizontal ? width : height;\r\n\r\n  if (width < 2 || height < 2) return;\r\n\r\n  if (orientation === horizontal && typeof startX !== 'undefined') {\r\n    divide(startPos, length, orientation, animations, offset);\r\n    const heightUp = startX - 1;\r\n    const heightDown = height - startX;\r\n    recursiveDivisionHelper(\r\n      heightUp, width,\r\n      chooseOrientation(heightUp, width), animations, offset,\r\n    );\r\n    recursiveDivisionHelper(\r\n      heightDown, width,\r\n      chooseOrientation(heightDown, width), animations, { x: offset.x, y: offset.y + startX },\r\n    );\r\n  } else if (orientation !== horizontal && typeof startY !== 'undefined') {\r\n    divide(startPos, length, orientation, animations, offset);\r\n    const widthLeft = startY - 1;\r\n    const widthRight = width - startY;\r\n    recursiveDivisionHelper(\r\n      height, widthLeft,\r\n      chooseOrientation(height, widthLeft), animations, offset,\r\n    );\r\n    recursiveDivisionHelper(\r\n      height, widthRight,\r\n      chooseOrientation(height, widthRight), animations, { x: offset.x + startY, y: offset.y },\r\n    );\r\n  }\r\n};\r\n\r\nconst animateRecursiveDivision = (\r\n  nodes: HTMLDivElement[], animations: number[], hideCover: () => void,\r\n) => {\r\n  resetTimeouts([]);\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    const timer = window.setTimeout(() => {\r\n      const nodeIdx = animations[i];\r\n      addRemoveWallNode(nodes[nodeIdx], nodeIdx);\r\n      if (i === animations.length - 1) hideCover();\r\n    }, i * 10);\r\n\r\n    pushTimer(timer);\r\n  }\r\n};\r\n\r\nconst recursiveDivision = (\r\n  nodes: HTMLDivElement[], noOfRows: number, noOfNodes: number, hideCover: () => void,\r\n) => {\r\n  nodesH = nodes;\r\n  noOfNodesH = noOfNodes;\r\n  initialGap = 2;\r\n  const recursiveDivisionAnimations: number[] = [];\r\n  recursiveDivisionHelper(\r\n    noOfRows - 2, noOfNodesH - 2,\r\n    chooseOrientation(4, 4), recursiveDivisionAnimations, { x: 0, y: 0 },\r\n  );\r\n\r\n  let animations: (number | number[])[] = [];\r\n  // up\r\n  drawSideWalls(nodes, noOfRows, noOfNodes, wallSideUp, animations);\r\n  // right left\r\n  drawSideWalls(nodes, noOfRows, noOfNodes, wallSideRightLeft, animations);\r\n  // down\r\n  animations = drawSideWalls(nodes, noOfRows, noOfNodes, wallSideDown, animations);\r\n  animateDrawWalls(\r\n    animations, nodes, noOfNodes,\r\n    recursiveDivisionAnimations, hideCover, animateRecursiveDivision,\r\n  );\r\n};\r\n\r\nexport default recursiveDivision;\r\n","import { addRemoveWallNode } from '../helperFunctions/helperFunctions';\r\nimport { resetTimeouts, pushTimer } from './mazesAndPatternsHelper';\r\n\r\nconst simpleStairPattern = (\r\n  nodes: HTMLDivElement[],\r\n  noOfRows: number,\r\n  noOfNodes: number,\r\n  hideCover: () => void,\r\n) => {\r\n  const startRow = Math.floor(noOfRows / 2);\r\n  const startCol = Math.floor(noOfNodes / 2);\r\n  const startNode = (startRow * noOfNodes) + startCol;\r\n  const stairLength = Math.floor(noOfRows / 4);\r\n  // const endColLeft = startCol;\r\n  const endColRIght = noOfNodes % 2 === 0 ? startCol - 1 : startCol;\r\n  addRemoveWallNode(nodes[startNode], startNode);\r\n\r\n  // actual startNode\r\n  const startNodeA = (startRow * noOfNodes) + Math.floor(noOfNodes / 4);\r\n  // actual targetNode\r\n  const targetNodeA = (startRow * noOfNodes) + noOfNodes - Math.floor(noOfNodes / 4) - 1;\r\n\r\n  let stairLengthH = 0;\r\n  let status = 'increment';\r\n  resetTimeouts([]);\r\n  const animations: number[] = [];\r\n  for (let i = 1; i < startCol; i += 1) {\r\n    if (stairLengthH === stairLength) status = 'decrement';\r\n    if (stairLengthH === 0) status = 'increment';\r\n    if (stairLengthH < stairLength && status === 'increment') {\r\n      stairLengthH += 1;\r\n    } else {\r\n      stairLengthH -= 1;\r\n    }\r\n\r\n    const upNodeLeftIdx = ((startRow - stairLengthH) * noOfNodes) + (startCol - i);\r\n    const downNodeLeftIdx = ((startRow + stairLengthH) * noOfNodes) + (startCol - i);\r\n    const downNodeLeftIdxRow = Math.floor(downNodeLeftIdx / noOfNodes);\r\n    const upNodeRightIdx = ((startRow - stairLengthH) * noOfNodes) + (startCol + i);\r\n    const downNodeRightIdx = ((startRow + stairLengthH) * noOfNodes) + (startCol + i);\r\n    const downNodeRightIdxRow = Math.floor(downNodeRightIdx / noOfNodes);\r\n\r\n    animations.push(upNodeLeftIdx);\r\n    if (downNodeLeftIdxRow !== startRow) {\r\n      animations.push(downNodeLeftIdx);\r\n    }\r\n    if (downNodeLeftIdxRow === startRow && downNodeLeftIdx < startNodeA) {\r\n      animations.push(downNodeLeftIdx);\r\n    }\r\n\r\n    if (i < endColRIght) {\r\n      animations.push(upNodeRightIdx);\r\n      if (downNodeRightIdxRow !== startRow) {\r\n        animations.push(downNodeRightIdx);\r\n      }\r\n      if (downNodeRightIdxRow === startRow && downNodeRightIdx > targetNodeA) {\r\n        animations.push(downNodeRightIdx);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    const timer = window.setTimeout(() => {\r\n      const nodeIdx = animations[i];\r\n      addRemoveWallNode(nodes[nodeIdx], nodeIdx);\r\n      if (i === animations.length - 1) hideCover();\r\n    }, i * 20);\r\n\r\n    pushTimer(timer);\r\n  }\r\n};\r\n\r\nexport default simpleStairPattern;\r\n","import { addRemoveWallNode } from '../helperFunctions/helperFunctions';\r\nimport {\r\n  animateDrawWalls,\r\n  drawSideWalls, wallSideDown, wallSideRightLeft, wallSideUp,\r\n} from './animateDrawSideWalls';\r\nimport {\r\n  chooseOrientation,\r\n  divide, getStartXY, horizontal, offSetType, pushTimer, resetTimeouts,\r\n} from './mazesAndPatternsHelper';\r\n\r\n// HS horizontal skew\r\n// H for helper\r\n\r\nlet nodesH: HTMLDivElement[] = [];\r\nlet noOfNodesH: number = 0;\r\n\r\nconst recursiveDivisionHorizontalSkewHelper = (\r\n  height: number, width: number,\r\n  orientation: string, animations: number[], offset: offSetType,\r\n) => {\r\n  const startX = getStartXY(height, 'X');\r\n  const startY = getStartXY(width, 'Y');\r\n  const startPos = orientation === horizontal ? startX : startY;\r\n  const length = orientation === horizontal ? width : height;\r\n\r\n  if (width < 2 || height < 2) return;\r\n\r\n  if (orientation === horizontal && typeof startX !== 'undefined') {\r\n    divide(nodesH, noOfNodesH, startPos, length, orientation, animations, offset);\r\n    const heightUp = startX - 1;\r\n    const heightDown = height - startX;\r\n    recursiveDivisionHorizontalSkewHelper(\r\n      heightUp, width,\r\n      horizontal, animations, offset,\r\n    );\r\n    recursiveDivisionHorizontalSkewHelper(\r\n      heightDown, width,\r\n      chooseOrientation(heightDown, width), animations, { x: offset.x, y: offset.y + startX },\r\n    );\r\n  } else if (orientation !== horizontal && typeof startY !== 'undefined') {\r\n    divide(nodesH, noOfNodesH, startPos, length, orientation, animations, offset);\r\n    const widthLeft = startY - 1;\r\n    const widthRight = width - startY;\r\n    recursiveDivisionHorizontalSkewHelper(\r\n      height, widthLeft,\r\n      horizontal, animations, offset,\r\n    );\r\n    recursiveDivisionHorizontalSkewHelper(\r\n      height, widthRight,\r\n      chooseOrientation(height, widthRight), animations, { x: offset.x + startY, y: offset.y },\r\n    );\r\n  }\r\n\r\n  if (\r\n    orientation === horizontal && typeof startX === 'undefined'\r\n    && typeof startY !== 'undefined' && height === 2\r\n  ) {\r\n    divide(nodesH, noOfNodesH, startY, height, 'vertical', animations, offset);\r\n    const widthLeft = startY - 1;\r\n    const widthRight = width - startY;\r\n    recursiveDivisionHorizontalSkewHelper(\r\n      height, widthLeft,\r\n      horizontal, animations, offset,\r\n    );\r\n    recursiveDivisionHorizontalSkewHelper(\r\n      height, widthRight,\r\n      horizontal, animations, { x: offset.x + startY, y: offset.y },\r\n    );\r\n  }\r\n};\r\n\r\nconst animateRecursiveDivisionHS = (\r\n  nodes: HTMLDivElement[], animations: number[], hideCover: () => void,\r\n) => {\r\n  resetTimeouts([]);\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    const timer = window.setTimeout(() => {\r\n      const nodeIdx = animations[i];\r\n      addRemoveWallNode(nodes[nodeIdx], nodeIdx);\r\n      if (i === animations.length - 1) hideCover();\r\n    }, i * 10);\r\n\r\n    pushTimer(timer);\r\n  }\r\n};\r\n\r\nconst recursiveDivisionHorizontalSkew = (\r\n  nodes: HTMLDivElement[], noOfRows: number, noOfNodes: number, hideCover: () => void,\r\n) => {\r\n  nodesH = nodes;\r\n  noOfNodesH = noOfNodes;\r\n  const recursiveDivisionAnimations: number[] = [];\r\n  recursiveDivisionHorizontalSkewHelper(\r\n    noOfRows - 2, noOfNodesH - 2,\r\n    horizontal, recursiveDivisionAnimations, { x: 0, y: 0 },\r\n  );\r\n\r\n  let animations: (number | number[])[] = [];\r\n  // up\r\n  drawSideWalls(nodes, noOfRows, noOfNodes, wallSideUp, animations);\r\n  // right left\r\n  drawSideWalls(nodes, noOfRows, noOfNodes, wallSideRightLeft, animations);\r\n  // down\r\n  animations = drawSideWalls(nodes, noOfRows, noOfNodes, wallSideDown, animations);\r\n  animateDrawWalls(\r\n    animations, nodes, noOfNodes,\r\n    recursiveDivisionAnimations, hideCover, animateRecursiveDivisionHS,\r\n  );\r\n};\r\n\r\nexport default recursiveDivisionHorizontalSkew;\r\n","import { addRemoveWallNode } from '../helperFunctions/helperFunctions';\r\nimport {\r\n  animateDrawWalls, drawSideWalls, wallSideDown, wallSideRightLeft, wallSideUp,\r\n} from './animateDrawSideWalls';\r\nimport {\r\n  chooseOrientation,\r\n  divide,\r\n  getStartXY, horizontal, offSetType, pushTimer, resetTimeouts,\r\n} from './mazesAndPatternsHelper';\r\n\r\n// VS for vertical skew\r\n// H for helper\r\nlet nodesH: HTMLDivElement[] = [];\r\nlet noOfNodesH: number = 0;\r\n\r\nconst recursiveDivisionVerticalSkewHelper = (\r\n  height: number, width: number,\r\n  orientation: string, animations: number[], offset: offSetType,\r\n) => {\r\n  const startX = getStartXY(height, 'X');\r\n  const startY = getStartXY(width, 'Y');\r\n  const startPos = orientation === horizontal ? startX : startY;\r\n  const length = orientation === horizontal ? width : height;\r\n\r\n  if (width < 2 || height < 2) return;\r\n\r\n  if (orientation === horizontal && typeof startX !== 'undefined') {\r\n    divide(nodesH, noOfNodesH, startPos, length, orientation, animations, offset);\r\n    const heightUp = startX - 1;\r\n    const heightDown = height - startX;\r\n    recursiveDivisionVerticalSkewHelper(\r\n      heightUp, width,\r\n      'vertical', animations, offset,\r\n    );\r\n    recursiveDivisionVerticalSkewHelper(\r\n      heightDown, width,\r\n      chooseOrientation(heightDown, width), animations, { x: offset.x, y: offset.y + startX },\r\n    );\r\n  } else if (orientation !== horizontal && typeof startY !== 'undefined') {\r\n    divide(nodesH, noOfNodesH, startPos, length, orientation, animations, offset);\r\n    const widthLeft = startY - 1;\r\n    const widthRight = width - startY;\r\n    recursiveDivisionVerticalSkewHelper(\r\n      height, widthLeft,\r\n      'vertical', animations, offset,\r\n    );\r\n    recursiveDivisionVerticalSkewHelper(\r\n      height, widthRight,\r\n      chooseOrientation(height, widthRight), animations, { x: offset.x + startY, y: offset.y },\r\n    );\r\n  }\r\n\r\n  if (\r\n    orientation !== horizontal && typeof startY === 'undefined'\r\n    && typeof startX !== 'undefined' && width === 2\r\n  ) {\r\n    divide(nodesH, noOfNodesH, startX, width, horizontal, animations, offset);\r\n    const heightUp = startX - 1;\r\n    const heightDown = height - startX;\r\n    recursiveDivisionVerticalSkewHelper(\r\n      heightUp, width,\r\n      'vertical', animations, offset,\r\n    );\r\n    recursiveDivisionVerticalSkewHelper(\r\n      heightDown, width,\r\n      'vertical', animations, { x: offset.x, y: offset.y + startX },\r\n    );\r\n  }\r\n};\r\n\r\nconst animateRecursiveDivisionVS = (\r\n  nodes: HTMLDivElement[], animations: number[], hideCover: () => void,\r\n) => {\r\n  resetTimeouts([]);\r\n  for (let i = 0; i < animations.length; i += 1) {\r\n    const timer = window.setTimeout(() => {\r\n      const nodeIdx = animations[i];\r\n      addRemoveWallNode(nodes[nodeIdx], nodeIdx);\r\n      if (i === animations.length - 1) hideCover();\r\n    }, i * 10);\r\n\r\n    pushTimer(timer);\r\n  }\r\n};\r\n\r\nconst recursiveDivisionVerticalSkew = (\r\n  nodes: HTMLDivElement[], noOfRows: number, noOfNodes: number, hideCover: () => void,\r\n) => {\r\n  nodesH = nodes;\r\n  noOfNodesH = noOfNodes;\r\n  const recursiveDivisionAnimations: number[] = [];\r\n  recursiveDivisionVerticalSkewHelper(\r\n    noOfRows - 2, noOfNodesH - 2,\r\n    'vertical', recursiveDivisionAnimations, { x: 0, y: 0 },\r\n  );\r\n\r\n  let animations: (number | number[])[] = [];\r\n  // up\r\n  drawSideWalls(nodes, noOfRows, noOfNodes, wallSideUp, animations);\r\n  // right left\r\n  drawSideWalls(nodes, noOfRows, noOfNodes, wallSideRightLeft, animations);\r\n  // down\r\n  animations = drawSideWalls(nodes, noOfRows, noOfNodes, wallSideDown, animations);\r\n  animateDrawWalls(\r\n    animations, nodes, noOfNodes,\r\n    recursiveDivisionAnimations, hideCover, animateRecursiveDivisionVS,\r\n  );\r\n};\r\n\r\nexport default recursiveDivisionVerticalSkew;\r\n","import { useEffect, useRef, useState } from 'react';\r\nimport TopNav from './components/TopNav';\r\nimport BottomNav from './components/BottomNav';\r\nimport SideNav from './components/SideNav';\r\nimport MazesPatternSwitchButton from './components/MazesPatternSwitchButton';\r\nimport PathFindingGrid from './components/PathFindingGrid';\r\nimport { RowsType } from './helperFunctions/types';\r\nimport {\r\n  generatePfGrid, getNewPfGridWithWallToggled, clearWalls, addBomb,\r\n  getBombIndex, clearPathNodes, resetBoard,\r\n} from './App.Functions';\r\nimport {\r\n  getNodeBombInfo, getNodeStartInfo, getNodeTargetInfo, setDarkMode,\r\n} from './helperFunctions/helperFunctions';\r\nimport { mazesKeys } from './mazesAndPatterns/mazesAndPatternsOptions';\r\nimport basicRandomMaze from './mazesAndPatterns/basicRandomMaze';\r\nimport recursiveDivision from './mazesAndPatterns/recursiveDivision';\r\nimport simpleStairPattern from './mazesAndPatterns/simpleStairPattern';\r\nimport './App.css';\r\nimport { topNav, bottomNav } from './helperFunctions/props';\r\nimport { clearTimeouts } from './mazesAndPatterns/mazesAndPatternsHelper';\r\nimport recursiveDivisionHorizontalSkew from './mazesAndPatterns/recursiveDivisionHorizontalSkew';\r\nimport recursiveDivisionVerticalSkew from './mazesAndPatterns/recursiveDivisionVerticalSkew';\r\n\r\n// pf => pathfinding\r\nlet isSliderChecked = false;\r\nlet debounceTimer: number = 0;\r\nlet pfGridWidth = 0;\r\nlet pfGridTopMargin = 0;\r\nlet isMousePressed = false;\r\nlet noOfRows = 0;\r\nlet noOfNodes = 0;\r\nlet currentActiveMazeAndPattern = 0;\r\n\r\nconst debounce = (callBack: () => void, time: number = 305) => {\r\n  debounceTimer = 0;\r\n  return () => {\r\n    if (debounceTimer) clearTimeout(debounceTimer);\r\n    debounceTimer = window.setTimeout(callBack, time);\r\n  };\r\n};\r\n\r\nfunction App() {\r\n  const [pfGridHeight, setPfGridHeight] = useState(0);\r\n  const [pfGridRows, setPfgridRows] = useState<RowsType>([]);\r\n\r\n  const topNavRef = useRef<HTMLDivElement>(null);\r\n  const bottomNavRef = useRef<HTMLDivElement>(null);\r\n  const pfGridRef = useRef<HTMLDivElement>(null);\r\n  const openSideNavRef = useRef<HTMLDivElement>(null);\r\n  const sideNavRef = useRef<HTMLDivElement>(null);\r\n  const nodesRef = useRef<Array<HTMLDivElement>>([]);\r\n  const animateCoverRef = useRef<HTMLDivElement>(null);\r\n  const mazesPatternDetailRef = useRef<HTMLDivElement>(null);\r\n  const speedSideNavRef = useRef<HTMLDivElement>(null);\r\n  // bottom and top ref for putting active item\r\n  const mazesPatternButtonsRefTop = useRef<Array<HTMLButtonElement>>([]);\r\n  const mazesPatternButtonsRefBottom = useRef<Array<HTMLButtonElement>>([]);\r\n\r\n  const calculateAndSetDimension = useRef(() => {});\r\n\r\n  const semanticUIDarkMode = (element: HTMLElement) => {\r\n    // H for helper\r\n    const elementH = element;\r\n    element.classList.add('inverted');\r\n\r\n    if (element === topNavRef.current!!) {\r\n      elementH.style.borderBottom = '1px solid #767676';\r\n    } else if (element === bottomNavRef.current!!) {\r\n      elementH.style.borderTop = '1px solid #767676';\r\n    } else {\r\n      elementH.style.borderTop = '1px solid #767676';\r\n      elementH.style.borderRight = '1px solid #767676';\r\n      elementH.style.borderBottom = '1px solid #767676';\r\n    }\r\n  };\r\n\r\n  const semanticUILightMode = (element: HTMLElement) => {\r\n    // H for helper\r\n    const elementH = element;\r\n    element.classList.remove('inverted');\r\n    elementH.style.border = '1px solid rgba(34, 36, 38, .15)';\r\n  };\r\n\r\n  const darkModeToggle = (checked: boolean) => {\r\n    isSliderChecked = checked;\r\n    const isChecked = checked;\r\n    if (isChecked) {\r\n      document.body.style.backgroundColor = '#1b1c1d';\r\n      semanticUIDarkMode(topNavRef.current!!);\r\n      semanticUIDarkMode(bottomNavRef.current!!);\r\n      semanticUIDarkMode(sideNavRef.current!!);\r\n      semanticUIDarkMode(openSideNavRef.current!!);\r\n      nodesRef.current[getNodeStartInfo().index].children[0].classList.add('inverted');\r\n      nodesRef.current[getNodeTargetInfo().index].children[0].classList.add('inverted');\r\n      if (getBombIndex() !== -1) {\r\n        nodesRef.current[getNodeBombInfo().index].children[0].classList.add('inverted');\r\n      }\r\n      setDarkMode(isChecked);\r\n      speedSideNavRef.current?.classList.add('speed-menu-inverted', 'inverted');\r\n    } else {\r\n      document.body.style.backgroundColor = '#ffffff';\r\n      semanticUILightMode(topNavRef.current!!);\r\n      semanticUILightMode(bottomNavRef.current!!);\r\n      semanticUILightMode(sideNavRef.current!!);\r\n      semanticUILightMode(openSideNavRef.current!!);\r\n      nodesRef.current[getNodeStartInfo().index].children[0].classList.remove('inverted');\r\n      nodesRef.current[getNodeTargetInfo().index].children[0].classList.remove('inverted');\r\n      if (getBombIndex() !== -1) {\r\n        nodesRef.current[getNodeBombInfo().index].children[0].classList.remove('inverted');\r\n      }\r\n      setDarkMode(isChecked);\r\n      speedSideNavRef.current?.classList.remove('speed-menu-inverted', 'inverted');\r\n    }\r\n  };\r\n\r\n  const handleMouseDown = (elem: HTMLElement) => {\r\n    isMousePressed = true;\r\n    getNewPfGridWithWallToggled(elem, nodesRef.current);\r\n  };\r\n\r\n  const handleMouseEnter = (elem: HTMLElement) => {\r\n    if (!isMousePressed) return;\r\n    getNewPfGridWithWallToggled(elem, nodesRef.current);\r\n  };\r\n\r\n  const handleMouseUp = () => {\r\n    isMousePressed = false;\r\n  };\r\n\r\n  // reset mazes and patters\r\n  const resetMazesAndPatterns = () => {\r\n    if (mazesPatternButtonsRefTop.current.length !== 0) {\r\n      mazesPatternButtonsRefTop.current!![currentActiveMazeAndPattern].classList.remove('active');\r\n      mazesPatternButtonsRefTop.current!![0].classList.add('active');\r\n    }\r\n\r\n    if (mazesPatternButtonsRefBottom.current.length !== 0) {\r\n      mazesPatternButtonsRefBottom.current!![currentActiveMazeAndPattern].classList.remove('active');\r\n      mazesPatternButtonsRefBottom.current!![0].classList.add('active');\r\n    }\r\n\r\n    mazesPatternDetailRef.current!!.textContent = 'None';\r\n    currentActiveMazeAndPattern = 0;\r\n  };\r\n\r\n  // show cover\r\n  const showCover = () => {\r\n    animateCoverRef.current!!.style.display = 'block';\r\n  };\r\n\r\n  // hide cover\r\n  const hideCover = () => {\r\n    animateCoverRef.current!!.style.display = 'none';\r\n  };\r\n\r\n  // mazes and patterns\r\n  const animateMazesAndPatterns = (maze: string, idx: number) => {\r\n    clearWalls(nodesRef.current, resetMazesAndPatterns);\r\n    const index = currentActiveMazeAndPattern;\r\n    currentActiveMazeAndPattern = idx;\r\n    mazesPatternDetailRef.current!!.textContent = maze;\r\n\r\n    if (mazesPatternButtonsRefTop.current.length !== 0) {\r\n      mazesPatternButtonsRefTop.current!![index].classList.remove('active');\r\n      mazesPatternButtonsRefTop.current!![idx].classList.add('active');\r\n    }\r\n\r\n    if (mazesPatternButtonsRefBottom.current.length !== 0) {\r\n      mazesPatternButtonsRefBottom.current!![index].classList.remove('active');\r\n      mazesPatternButtonsRefBottom.current!![idx].classList.add('active');\r\n    }\r\n\r\n    switch (maze) {\r\n      case mazesKeys[0]:\r\n        clearWalls(nodesRef.current, resetMazesAndPatterns);\r\n        break;\r\n      case mazesKeys[1]:\r\n        showCover();\r\n        basicRandomMaze(nodesRef.current, noOfRows, noOfNodes, hideCover);\r\n        break;\r\n      case mazesKeys[2]:\r\n        showCover();\r\n        recursiveDivision(nodesRef.current, noOfRows, noOfNodes, hideCover);\r\n        break;\r\n      case mazesKeys[3]:\r\n        showCover();\r\n        recursiveDivisionHorizontalSkew(nodesRef.current, noOfRows, noOfNodes, hideCover);\r\n        break;\r\n      case mazesKeys[4]:\r\n        showCover();\r\n        recursiveDivisionVerticalSkew(nodesRef.current, noOfRows, noOfNodes, hideCover);\r\n        break;\r\n      case mazesKeys[5]:\r\n        showCover();\r\n        simpleStairPattern(nodesRef.current, noOfRows, noOfNodes, hideCover);\r\n        break;\r\n      default:\r\n        return 0;\r\n    }\r\n    return 0;\r\n  };\r\n\r\n  calculateAndSetDimension.current = () => {\r\n    clearTimeouts();\r\n    resetMazesAndPatterns();\r\n    animateCoverRef.current!!.style.display = 'none';\r\n    clearWalls(nodesRef.current, resetMazesAndPatterns);\r\n    nodesRef.current.length = 0;\r\n\r\n    const sideNavAddBomb = sideNavRef.current?.children[1];\r\n    const addBombElem = sideNavAddBomb!!.children[1];\r\n    addBombElem.textContent = 'Add Bomb';\r\n\r\n    const windowHeight = window.innerHeight;\r\n    const pfGridOffset = pfGridRef.current!!.offsetTop;\r\n    const bottomNavHeight = bottomNavRef.current!!.clientHeight;\r\n\r\n    const remainingWindowHeight = windowHeight - pfGridOffset;\r\n    // minus 10 for bottom margin\r\n    const height = remainingWindowHeight - bottomNavHeight - 10;\r\n\r\n    setPfGridHeight(height);\r\n    pfGridWidth = pfGridRef.current!!.clientWidth;\r\n\r\n    // dividing by 25 the height and width of each node\r\n    noOfRows = Math.floor(height / 25);\r\n    noOfNodes = Math.floor(pfGridWidth / 25);\r\n    const remaingSpace = height - (height - noOfRows);\r\n    // -1 for border of 1px\r\n    pfGridTopMargin = (remaingSpace / 2) - 1;\r\n    const rows: RowsType = generatePfGrid(noOfRows, noOfNodes);\r\n    setPfgridRows(rows);\r\n    clearTimeout(debounceTimer);\r\n  };\r\n\r\n  useEffect(() => {\r\n    // effect\r\n    calculateAndSetDimension.current();\r\n    window.addEventListener('resize', debounce(calculateAndSetDimension.current));\r\n    window.addEventListener('mouseup', handleMouseUp);\r\n    return () => {\r\n      // cleanup\r\n      window.removeEventListener('resize', debounce(calculateAndSetDimension.current));\r\n      window.removeEventListener('mouseup', handleMouseUp);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <TopNav\r\n        navType={topNav}\r\n        ref={topNavRef}\r\n        arrowDirection=\"\"\r\n        animateMazesAndPatterns={animateMazesAndPatterns}\r\n        mazesPatternButtonsRef={[mazesPatternButtonsRefTop, mazesPatternButtonsRefBottom]}\r\n        currentActiveMazeAndPattern={currentActiveMazeAndPattern}\r\n        nodes={nodesRef}\r\n        noOfRows={noOfRows}\r\n        noOfNodes={noOfNodes}\r\n        sideNav={sideNavRef}\r\n        showCover={showCover}\r\n        hideCover={hideCover}\r\n      />\r\n\r\n      {/* <OpenSideNav\r\n        ref={openSideNavRef}\r\n        top={pfGridRef.current === null ? 0 : pfGridRef.current!!.offsetTop}\r\n        height={0}\r\n        sideNavRef={sideNavRef}\r\n      /> */}\r\n\r\n      <SideNav\r\n        ref={sideNavRef}\r\n        top={pfGridRef.current === null ? 0 : pfGridRef.current!!.offsetTop}\r\n        height={pfGridHeight}\r\n        addBomb={\r\n          // eslint-disable-next-line max-len\r\n          () => { addBomb(noOfNodes, nodesRef.current, sideNavRef.current); }\r\n        }\r\n        resetBoard={\r\n          () => {\r\n            resetBoard(\r\n              nodesRef.current, noOfRows, noOfNodes, resetMazesAndPatterns, sideNavRef.current,\r\n            );\r\n          }\r\n        }\r\n        clearPathNodes={() => { clearPathNodes(nodesRef.current); }}\r\n        clearWalls={() => { clearWalls(nodesRef.current, resetMazesAndPatterns); }}\r\n        speedSideNavRef={speedSideNavRef}\r\n        openSideNavRef={openSideNavRef}\r\n      />\r\n\r\n      <MazesPatternSwitchButton\r\n        ref={mazesPatternDetailRef}\r\n        isSliderChecked={isSliderChecked}\r\n        darkModeToggle={darkModeToggle}\r\n      />\r\n\r\n      <PathFindingGrid\r\n        ref={pfGridRef}\r\n        pfGridHeight={pfGridHeight}\r\n        marginTop={pfGridTopMargin}\r\n        pfGridRows={pfGridRows}\r\n        nodesRef={nodesRef}\r\n        noOfNodes={noOfNodes}\r\n        onMouseDown={handleMouseDown}\r\n        onMouseEnter={handleMouseEnter}\r\n      />\r\n\r\n      <BottomNav\r\n        navType={bottomNav}\r\n        ref={bottomNavRef}\r\n        arrowDirection=\"\"\r\n        animateMazesAndPatterns={animateMazesAndPatterns}\r\n        mazesPatternButtonsRef={[mazesPatternButtonsRefTop, mazesPatternButtonsRefBottom]}\r\n        currentActiveMazeAndPattern={currentActiveMazeAndPattern}\r\n      />\r\n      <div className=\"cover-div cover-div-error\">\r\n        <div className=\"error-div\">Use Screen of width 320px and above</div>\r\n      </div>\r\n\r\n      {/* h for height */}\r\n      <div className=\"cover-div cover-div-error-h\">\r\n        <div className=\"error-div\">Use Screen of height 320px and above</div>\r\n      </div>\r\n\r\n      <div className=\"cover-div\" ref={animateCoverRef} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({\r\n      getCLS, getFID, getFCP, getLCP, getTTFB,\r\n    }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport 'semantic-ui-css/semantic.min.css';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root'),\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}